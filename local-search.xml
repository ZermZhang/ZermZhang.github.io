<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python常用的udf的简要说明</title>
    <link href="/2024/05/24/python/udf/python%E5%B8%B8%E7%94%A8%E7%9A%84udf%E7%9A%84%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/"/>
    <url>/2024/05/24/python/udf/python%E5%B8%B8%E7%94%A8%E7%9A%84udf%E7%9A%84%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>udf是在pandas数据处理和pyspark数据处理开发过程一个常用的逻辑，即自定义函数。<br>虽然pandas和pyspark都提供了强大和灵活的内置处理逻辑，但是在遇到一些复杂的处理过程的时候，udf还是无法绕过的一步。</p><h1 id="常用的udf类型"><a href="#常用的udf类型" class="headerlink" title="常用的udf类型"></a>常用的udf类型</h1><table><thead><tr><th>作用范围</th><th>方法名</th><th>备注</th></tr></thead><tbody><tr><td>pd.Series</td><td>map</td><td>把自定义函数映射到每一个元素上，同时可以把dict映射到元素上，通过key自动映射value</td></tr><tr><td>pd.Series</td><td>apply</td><td>只能把自定义函数映射到每一个元素上</td></tr><tr><td>pd.DataFrame</td><td>map</td><td>其实就是pd.Series的map，只能作用在pd.DataFrame的指定列，也就是一个Series上</td></tr><tr><td>pd.DataFrame</td><td>apply</td><td>把自定义函数映射到指定的坐标轴上，axis&#x3D;0，纵轴，axis&#x3D;1, 横轴</td></tr><tr><td>pd.DataFrame</td><td>applymap</td><td>把自定义函数映射到每一个元素上</td></tr><tr><td>pd.DataFrame</td><td>assign</td><td>为pd.DataFrame拓展列</td></tr><tr><td>pyspark.sql.DataFrame</td><td>mapInPandas</td><td>把df的每个分区当成pd.DataFrame来处理，需要返回一个df的可迭代器</td></tr><tr><td>pyspark.sql.DataFrame</td><td>applyInPandas</td><td>把group之后的每个分区内容当成pd.DataFrame来处理，返回df</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>udf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双拼进阶</title>
    <link href="/2023/09/04/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%8F%8C%E6%8B%BC%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/09/04/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%8F%8C%E6%8B%BC%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<ol><li><p>双拼依旧存在的问题<br>在经过了一段时间的联系后，双拼输入法的使用基本已经步入正轨了，日常的打字速度也基本达到并超越了之前使用全拼输入法的速度。日常的使用过程里也在各个场景里完成了针对全拼输入法的取代。<br>而且在使用的过程里，逐渐的发现了双拼输入法最大的优势，其实不是击键次数少之类的，而是在打字的时候，可以精确的保证每个字的击键次数都是2次，这样可以在打字的过程中，保持一种非常稳定的节奏，在逐渐的熟练之后，可以完全的实现打字和思考的并行化。极大的提高打字和思考的效率。<br>但是，于此同时，双拼输入法无法避免的一个问题也逐渐的暴漏了出来，这就是频繁的选字过程。因为双拼打字和全拼打字背后的逻辑其实是一致的，只不过双拼打字只是把全拼里需要多次击键的声母和韵母使用了一次击键进行了替代，但是在输入了对应的拼音之后，选字的过程还是无法避免的，这个过程使得我们在打字的过程里需要不时的停下来，找出我们确实需要的字，然后再继续打字，然后再停下来，选字，然后再打字，这个过程是不断的循环往复的。某种程度上其实是严重的阻碍了我们的效率。</p></li><li><p>怎么解决这个问题？<br>为了解决这个问题，我们自然而然的接触到了双拼输入法进一步的提升方案，那就是——音形。<br>『小鹤音形』是单字以双拼（小鹤双拼）＋ 双形（鹤形）组合的标准四码音形类输入方案。<br>上面是小鹤音形的官网上的定义，但是这个定义其实在某种程度上弱化了小鹤音形的强大。小鹤音形的方案在小鹤双拼的基础上，通过学习五笔的方案，增加了形码的方法，大幅度的降低了重码的问题，提高了打字的效率，同时降低了形码入门困难的门槛。<br>通过上述两个有点，实现了五笔的快捷输入和拼音的快速入门的优势。</p></li><li><p>小鹤音形的优点<br>3.1 大幅度的降低了重码率<br>重码，在拼音打字的方案里，是一个绕不过去的问题，在我们日常的打字过程中，我们难免的要花费大量的时间来进行选字。那么减少了这个过程之后，自然就能够充分的提高打字的速度。<br>而音形就是利用了这个思想，在之前双拼的基础上，增加了双形的方案，实现了单字的精准定位，减少了选字的过程。<br>音形结合了双拼和形码的特点，通过拼音先选定词的池子，然后通过形码来具体的定位到具体的字。即前两个字母为双拼的音码，后两个字母为字的形码。<br>比如，“懿”这个字，在日常的使用中使用的频率较低，如果是通过拼音或者是双拼输入的话，需要的击键都是“yi”，然后在候选词里找到需要的“懿”字，但是通过音形的输入方法的话，直接通过“yiux”就可以直接的完成“懿”字的输入。<br>3.2 四键快速上屏<br>同时为了实现快速的打字，小鹤音形同样也支持四键快速上屏，也就是进行了四次的击键之后，可以自动的选中当前已经定位到的字。同上，“懿”字，当你输入了“yiux”之后，“懿”字就直接可以出现在屏幕上了，而不需要你再次的对这个字进行选定了。<br>同样，音形的输入法，也支持词组的快速输入，比如，输入“同样”这个词组，可以通过“tsyh”这样的四次击键实现快速的输入，这个时候的输入击键和双拼的逻辑是一致的，保证了从双拼转入到音形的便捷性。</p></li><li><p>小鹤音形的缺点<br>4.1 失去了双拼的节奏感<br>在之前的说明里我们提到了小鹤双拼的一大优点是打字的节奏感，每两次的击键就能选定一个字，而当我们切换到了小鹤音形之后，反而打破了这个节奏感。<br>因为在小鹤音形里，出现了单码字，双码字，三码字和四码字的区别，你需要根据不同的字进行不同的击键次数，从这个角度来说，形码反而是打破了双拼输入的节奏感和快乐。<br>4.2 需要克服从长句到单字的输入习惯<br>在我们使用拼音输入法和双拼输入法进行输入的时候，我们习惯通过多次的输入之后，然后对输入的每个字进行选字（当然，现在的输入法都有足够的智能，可以自动的定位到尽可能多的准确的字，而且随着技术的进步，可能输入的越长，准确度越高）。<br>但是，涉及到形码的输入法，每次的输入的节奏，就从长句的输入方式换成了单字的输入方式。每次最多输入两个字，也就是一个词组的时候，选定的字就默认上屏了，这个时候很少会留给你确认输入的字正确与否。<br>所以刚开始使用音形输入法的时候，发现经常的出现了把字输入完成之后，才发现输入错了。<br>这个变化需要在使用的过程里尽可能的适应。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双拼介绍</title>
    <link href="/2023/05/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%8F%8C%E6%8B%BC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/05/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E5%8F%8C%E6%8B%BC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习使用双拼，这里记录一下在双拼的学习过程中的一些收获或者是发现的一些问题。</p></blockquote><h1 id="1-为什么要学习双拼？"><a href="#1-为什么要学习双拼？" class="headerlink" title="1. 为什么要学习双拼？"></a>1. 为什么要学习双拼？</h1><p>近期在打字的时候突然发现自己的打字的速度好像到了一个瓶颈了，很难在有一些比较明显的提升，然后为了找出背后的原因初步分析了一些现在自己打字的过程中可能存在的一些问题：</p><ol><li>击键不准；在打字的过程中，经常会出现击键不准的情况，比如按<code>L</code>的时候不小心按到了<code>;</code>，或者是出现了双击，比如同时按到了<code>I</code>和<code>O</code></li><li>字音不清晰；在打字的过程中发现会对一些常用字的发音不清楚，导致打字的时候经常会打错音，从而需要不断地退格删除</li><li>击键手法已经形成了肌肉记忆；很多打字的时候，手速要比意识快，自我感觉还没有完全想明白的时候就已经开始打了<br>整体看下来，大部分的问题出自使用全拼打字的时候，很多开始学习打字的时候的坏习惯已经严重的影响到了后续的打字效率的提升上。<br>所以想找一个新的打字方法，从头练起，同时纠正一下坏习惯，提升打字的效率。<br>现在常用到的打字的方法主要就是：全拼、五笔、双拼三种，五笔背词根的过程曾经在我幼小的心灵里留下了难以磨灭的印象，即使是现在也很难有勇气再重新拾起这项技能了，所以就只好投奔到双拼的怀抱里了。</li></ol><h1 id="2-什么是双拼？"><a href="#2-什么是双拼？" class="headerlink" title="2. 什么是双拼？"></a>2. 什么是双拼？</h1><p>双拼是针对全拼输入法的一种优化方法。<br>在全拼输入法中，键盘的没个字母都代表一个拼音字母，但是在双拼里，每个字母分别会对应到不同的声母和韵母。<br>这样，在日常打字的过程中，点击键盘的逻辑就从全拼的点击每个字母变成了点击当前字的声母部分和韵母部分，点击次数直线下降。<br>有人会疑惑，这样的话，打字速度会快么？感觉要多想一些。<br>其实，仔细的思考一下，你就会发现，使用双拼输入法的话，其实相较全拼输入法是会少一些操作的。</p><h2 id="2-1-常见的双拼输入法"><a href="#2-1-常见的双拼输入法" class="headerlink" title="2.1 常见的双拼输入法"></a>2.1 常见的双拼输入法</h2><p>常见的双拼输入法有：自然码、微软双拼、小鹤双拼、智能ABC、搜狗双拼。<br>在这些常用的双拼方案里，基本各有各自的优劣势，这里不做过多的介绍，大家可以在网上都能快速的找到对应的说明。<br>我选择的是小鹤双拼，一是因为这个输入法现在的支持的范围比较广，大部分的输入法都是原生支持的，而且mac的自带输入法里也自带了实现，切换的过程会比较的方便。<br>而是因为小鹤双拼的实现时间相对的比较靠后，相对的吸收了比较多的其他的双拼输入法的有点，较好的优化了双拼输入法较为别手的问题（虽然实际上还是难免会有一些别手的情况存在）。</p><h2 id="2-2-双拼输入法的优势"><a href="#2-2-双拼输入法的优势" class="headerlink" title="2.2 双拼输入法的优势"></a>2.2 双拼输入法的优势</h2><ol><li>一个字对应两次击键<br>我感觉这是双拼的输入法最大的优势。<br>你在输入的过程中，无论你输入的是什么字，他都会标准的对应到两次击键上。<br>这样最直接的影响就是，每个字的输入时长都是一致的，不会像是全拼一样，因为每个字对应的击键次数不一样，而导致不同自得输入过程耗时不同，你在输入一句话的时候在不同的字上，停留的时间是不一样的，在双拼这里，一句话的输入时间只和具体的字数有关，而和你输入的具体的字的内容是无关的。<br>当你对双拼的输入法逐渐的熟练之后，自然而然的就能体会到双拼输入法的节奏感。</li><li>熟练之后的打字速度的提升<br>这一点优势的来源其实也是第一点，因为每个字稳定的对应到了两次击键，所以整体的相较全拼输入法的击键次数是要少不少的，因此打字的速度在你熟练之后可以有客观的提升。我之前使用全拼的时候打字的速度大概是70wpm左右，在我转换为双拼的输入法之后，打字速度从最开始的40wpm随着熟练程度的逐渐上升而上升，大概两周之后，双拼的打字速度就已经超过全拼的速度达到了75~80wpm。</li></ol><h2 id="2-3-双拼输入法的劣势"><a href="#2-3-双拼输入法的劣势" class="headerlink" title="2.3 双拼输入法的劣势"></a>2.3 双拼输入法的劣势</h2><ol><li>一个字母代表了多个含义<br>在双拼输入法里，键盘的一个字母代表了多个含义。<br>首先，他代表了本身的字母，也就是拼音里的声母部分；同时，每一个字母也有他所对应的韵母的部分。比如，’R’代表了韵母’uan’, ‘U’代表了声母’ch’。<br>所以，你在输入的时候，会发现，每次击键的结果其实是根据你的输入的位置而有不一样的含义，比如你输入“无数上述例子”的时候，你在小鹤双拼下的击键顺序是“wuuuuhuulizi”，这么一大串的‘u’的输入，一个不小心，就不知道错在什么地方了。<br>这也是我在输入的过程中发现的最大的问题，但是随着你对双拼的输入法的熟练度逐渐的增加，你会慢慢的适应一个字对应两个击键的对应关系，慢慢的就能够梳理清楚这些状况了。</li><li>别手的情况<br>虽然小鹤双拼着重的优化了双拼输入的过程中的击键位置的别手的情况，但是还是无法很好的避免。<br>比如输入“暴躁”的时候，击键顺序是“bczc”，因为这些键位都出在左手的左下的位置，难免会有一些不太顺手。<br>但是这个情况，相对的也不会特别的多，所以在使用的过程中，稍微的注意一下就好。</li></ol>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>airflow使用mysql作为db</title>
    <link href="/2023/04/24/airflow/airflow%E4%BD%BF%E7%94%A8mysql%E4%BD%9C%E4%B8%BAdb/"/>
    <url>/2023/04/24/airflow/airflow%E4%BD%BF%E7%94%A8mysql%E4%BD%9C%E4%B8%BAdb/</url>
    
    <content type="html"><![CDATA[<blockquote><p>airflow在使用过程中的各种组件是可以进行适当的替换的，方便大家在使用过程中采用比较符合自己技术栈的相关组件。<br>比如，我们可以将airflow模型链接的数据库换成mysql</p></blockquote><ol><li>安装mysql服务</li><li>对mysql进行一定的配置<ol><li>启动mysql：<code>mysql</code></li><li>常见需要使用的数据库：<code>create database airflowdb;</code></li><li>检查数据库创建是否成功：<code>show databases;</code></li><li>给指定的用户适当的权限<ol><li><code>create user &#39;airflow&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</code></li><li><code>GRANT all privileges on airflowdb.* TO &#39;airlfow&#39;@&#39;%&#39;;</code><ol><li>将数据库airflowdb的所有权限赋予用户airflow，密码123456，且该用户可以在任何IP段进行操作</li></ol></li><li>官方文档中提示airflow只需要CREATE和ALTER权限</li><li>但是在实际使用中发现需要如下权限：<ol><li>CREATE，ALTER，INSERT，UPDATE，INDEX，DEL，SELECT，DROP，ALTER，REFERENCES</li></ol></li></ol></li><li>授权检查：<code>show grants for &#39;airflow&#39;@&#39;%&#39;;</code></li></ol></li><li>airflow.cfg配置文件调整<ol><li>sql_alchemy_conn &#x3D; mysql:&#x2F;&#x2F;airflow:123456@localhost&#x2F;airflowdb</li><li>sql_engine_encoding &#x3D; ascii<ol><li>默认值是utf-8，容易导致prefres超长的问题出现</li></ol></li></ol></li><li>重新初始化数据库<br> <code>airflow db init</code><br> 如果之前用过sqlite，可以使用<code>airflow db reset</code><br> 可能出现的问题：<ol><li>问题<br>  <img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230424112100.png" alt="image.png"><br> 解决：<code>apt-get install -y python3-mysqldb</code></li><li>问题<br>  <img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230424112148.png" alt="image.png"><br> 解决：创建database的时候指定ascii编码<br> <code>create database airflowdb CHARACTER SET ascii;</code></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>airflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>airflow</tag>
      
      <tag>调度器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spark中使用left-semi-join</title>
    <link href="/2023/03/29/spark/spark%E4%B8%AD%E4%BD%BF%E7%94%A8left-semi-join/"/>
    <url>/2023/03/29/spark/spark%E4%B8%AD%E4%BD%BF%E7%94%A8left-semi-join/</url>
    
    <content type="html"><![CDATA[<blockquote><p>left semi join是在Hive中常用的一种join方式，但是他和常用的join也会有一些不同。spark中也有一样的处理逻辑。那么使用过程中有哪些需要外注意到的东西呢？</p></blockquote><h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h2><p>left semi join是IN&#x2F;EXISTS的一种高效实现方法，可以用来处理两个DataFrame取交集的情况。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> spark<span class="token punctuation">.</span>createDataFrame<span class="token punctuation">(</span>    <span class="token punctuation">[</span>      <span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token string">"male"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token string">"jerry"</span><span class="token punctuation">,</span> <span class="token string">"female"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token string">"kevin"</span><span class="token punctuation">,</span> <span class="token string">"male"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"gender"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> spark<span class="token punctuation">.</span>createDataFrame<span class="token punctuation">(</span>    <span class="token punctuation">[</span>        <span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">,</span> <span class="token string">'male'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">'jerry'</span><span class="token punctuation">,</span> <span class="token string">'male'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'gender'</span><span class="token punctuation">,</span> <span class="token string">'salary'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>根据上面两个示例DataFrame，我们需要取b中name存在在a中的那些值，最简单的方法当然是通过join实现。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">same_name_df_join <span class="token operator">=</span> b<span class="token punctuation">.</span>join<span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">.</span>name <span class="token operator">==</span> b<span class="token punctuation">.</span>name<span class="token punctuation">,</span> how<span class="token operator">=</span><span class="token string">'inner'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">[</span>b<span class="token punctuation">.</span>name<span class="token punctuation">,</span> b<span class="token punctuation">.</span>gender<span class="token punctuation">,</span> b<span class="token punctuation">.</span>salary<span class="token punctuation">]</span><span class="token punctuation">)</span>same_name_df_join<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>结果+耗时：<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230329110540.png" alt="join结果耗时情况"><br>那么，这里我们可以通过left semi join实现想要的逻辑，可以用更短的时间实现更好的效果。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 根据name过滤b在a中</span>same_name_df <span class="token operator">=</span> b<span class="token punctuation">.</span>join<span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">.</span>name <span class="token operator">==</span> b<span class="token punctuation">.</span>name<span class="token punctuation">,</span> how<span class="token operator">=</span><span class="token string">'leftsemi'</span><span class="token punctuation">)</span>same_name_df<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230329110845.png" alt="left semi join结果耗时情况"><br>注意结果里的耗时情况，当然，测试的DataFrame数据很少，耗时情况不太置信，但是也能从一定程度上说明left semi join的高效了。<br>当然，在使用left semi join的时候，也想join一样，可以通过多个key进行处理。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 根据name+gender过滤b在a中</span>same_name_gender_df <span class="token operator">=</span> b<span class="token punctuation">.</span>join<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>name <span class="token operator">==</span> b<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>gender <span class="token operator">==</span> b<span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">,</span> how<span class="token operator">=</span><span class="token string">'leftsemi'</span><span class="token punctuation">)</span>same_name_gender_df<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230329110746.png" alt="多个key进行left semi join"></p><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h2><ol><li>使用Left semi join的时候，最终的输出结果里的col只能是存在在左边DataFrame的col，如果只在右边的DataFrame里有的话，是不能关联到结果里的</li><li>右边DataFrame如果存在重复数据的话，left semi join会直接跳过重复数据，而不会像join一样生成过个记录，这一点要额外注意。</li></ol>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spark</tag>
      
      <tag>join</tag>
      
      <tag>left semi join</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tensorflow常用计算逻辑</title>
    <link href="/2023/03/28/tensorflow/tensorflow%E5%B8%B8%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91/"/>
    <url>/2023/03/28/tensorflow/tensorflow%E5%B8%B8%E7%94%A8%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录tensorflow代码开发过程中常用的utils方法</p></blockquote><h3 id="1-计算向量的cosine相似度"><a href="#1-计算向量的cosine相似度" class="headerlink" title="1. 计算向量的cosine相似度"></a>1. 计算向量的cosine相似度</h3><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cos_dis</span><span class="token punctuation">(</span>tensor1<span class="token punctuation">,</span> tensor2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    cosine相似度：是计算两个向量之间的相似度常用的方法，通过两个向量之间的夹角大小来判断相似度。夹角越小，相似度越高    tensor1/tensor1: 维度一致的两个tensor，这里采用(n,)的标量作为介绍    """</span>    <span class="token comment"># 求模长</span>    tensor1_norm <span class="token operator">=</span> tf<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>reduce_sum<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>tensor1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    tensor2_norm <span class="token operator">=</span> tf<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>reduce_sum<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>tensor2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 计算内积</span>    tensor1_tensor2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_sum<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>tensor1<span class="token punctuation">,</span> tensor2<span class="token punctuation">)</span><span class="token punctuation">)</span>    cosin <span class="token operator">=</span> tensor1_tensor2 <span class="token operator">/</span> <span class="token punctuation">(</span>tensor1_norm <span class="token operator">*</span> tensor2_norm<span class="token punctuation">)</span>    <span class="token keyword">return</span> cosin<span class="token keyword">def</span> <span class="token function">cos_dis_v2</span><span class="token punctuation">(</span>tensor1<span class="token punctuation">,</span> tensor2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    功能同上，这里先讲两个tensor进行归一化，再直接计算内积，可以省去计算模的过程    """</span>    tensor1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>l2_normalize<span class="token punctuation">(</span>tensor1<span class="token punctuation">)</span>    tensor2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>l2_normalize<span class="token punctuation">(</span>tensor2<span class="token punctuation">)</span>    cosin <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_sum<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>tensor1<span class="token punctuation">,</span> tensor2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> cosin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>method</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spark的udf函数声明</title>
    <link href="/2023/03/27/spark/spark%E7%9A%84udf%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/"/>
    <url>/2023/03/27/spark/spark%E7%9A%84udf%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>udf（user defined function）函数，是spark中针对内建函数无法满足用户需求是，提供给用户的一种自定义处理函数的方式。<br>很好的扩展了用户在处理dataframe数据时候的自由度和便捷性。</p></blockquote><h2 id="0-产生例子"><a href="#0-产生例子" class="headerlink" title="0. 产生例子"></a>0. 产生例子</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pyspark<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>functions <span class="token keyword">as</span> f<span class="token keyword">from</span> pyspark<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>types <span class="token keyword">import</span> StringTypedf <span class="token operator">=</span> spark<span class="token punctuation">.</span>createDataFrame<span class="token punctuation">(</span>    <span class="token punctuation">[</span>      <span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">,</span> <span class="token string">"male"</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token string">"jerry"</span><span class="token punctuation">,</span> <span class="token string">"female"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span><span class="token string">"kevin"</span><span class="token punctuation">,</span> <span class="token string">"male"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>createOrReplaceTempView<span class="token punctuation">(</span><span class="token string">"namge_age_df"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>显示结果：<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230327192912.png" alt="df展示"><br>后续会在该示例df上展示pdf的功能</p><h2 id="1-udf创建方法"><a href="#1-udf创建方法" class="headerlink" title="1. udf创建方法"></a>1. udf创建方法</h2><p>udf函数有多种创建方法，但是，每种创建方法都离不开最基本的python函数。<br>这里的python函数和日常本地程序中使用到的函数没有任何的不通，大家可以通过最常用的方法进行处理。<br>这里，我们通过一个对年龄进行分类的例子进行说明。</p><h4 id="1-1-python函数的例子"><a href="#1-1-python函数的例子" class="headerlink" title="1.1 python函数的例子"></a>1.1 python函数的例子</h4><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bucket_age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> age <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'child'</span>    <span class="token keyword">elif</span> age <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'young'</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'adult'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>这是一个很简单的函数，我们通过16、30两个年龄，将所有人划分成了三个年龄段，如果是在本地的pyhton数据结构中，我们可以直接使用当前的pyhton函数进行处理，但是当我们面临的是一个数据量极多的pyspark-DataFrame的时候，我们就需要将当前函数转换成可以对DataFrame进行操作的udf函数。</li></ul><h4 id="1-2-使用-装饰器注册udf函数"><a href="#1-2-使用-装饰器注册udf函数" class="headerlink" title="1.2 使用@装饰器注册udf函数"></a>1.2 使用@装饰器注册udf函数</h4><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@f<span class="token punctuation">.</span>udf</span><span class="token punctuation">(</span>returnType<span class="token operator">=</span>StringType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">bucket_age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> age <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'child'</span>    <span class="token keyword">elif</span> age <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'young'</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'adult'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>使用这种方式注册udf，比较简单，编程逻辑和正常的python函数基本一致</li><li>但是将当前函数注册为udf函数后，不能独立命名，只能使用做udf函数，而且无法不方便处理多参数输入</li></ul><h4 id="1-3-直接注册为udf函数"><a href="#1-3-直接注册为udf函数" class="headerlink" title="1.3 直接注册为udf函数"></a>1.3 直接注册为udf函数</h4><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bucket_age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> age <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'child'</span>    <span class="token keyword">elif</span> age <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'young'</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'adult'</span>udf_bucket_age <span class="token operator">=</span> f<span class="token punctuation">.</span>udf<span class="token punctuation">(</span>bucket_age<span class="token punctuation">,</span> StringType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>最常见的注册方式，python函数和注册过程相互独立，方便测试和开发</li></ul><h4 id="1-4-使用闭包注册udf函数"><a href="#1-4-使用闭包注册udf函数" class="headerlink" title="1.4 使用闭包注册udf函数"></a>1.4 使用闭包注册udf函数</h4><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">udf_bucket_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bucket_age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> age <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'child'</span>        <span class="token keyword">elif</span> age <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'young'</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'adult'</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span>udf<span class="token punctuation">(</span>bucket_age<span class="token punctuation">,</span> StringType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>方便处理多参数输入的方式，而且能够在闭包函数中独立输入不变变量，方便区分不通的变量逻辑</li></ul><h2 id="2-udf的使用"><a href="#2-udf的使用" class="headerlink" title="2. udf的使用"></a>2. udf的使用</h2><h4 id="2-1-基于列的udf使用"><a href="#2-1-基于列的udf使用" class="headerlink" title="2.1 基于列的udf使用"></a>2.1 基于列的udf使用</h4><p>最常见的函数使用方式，即将当前的udf函数应用到dataframe的一列数据上，针对当前列进行处理，生成新的列。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">new_df <span class="token operator">=</span> df<span class="token punctuation">.</span>withColumn<span class="token punctuation">(</span><span class="token string">'bucket_age'</span><span class="token punctuation">,</span> udf_bucket_age<span class="token punctuation">(</span>f<span class="token punctuation">.</span>col<span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>new_df<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230327192952.png" alt="udf处理"></p><ul><li>如上，经过了注册后的udf函数处理后，dataframe中生成了新的一列，这一列正是对年龄的结果分桶后的结果。而且结果也正是我们在python函数中声明的逻辑。</li></ul><h4 id="2-2-基于agg的udf使用"><a href="#2-2-基于agg的udf使用" class="headerlink" title="2.2 基于agg的udf使用"></a>2.2 基于agg的udf使用</h4><p>在日常使用中，还有一种方式出现频率较高，那就是针对group聚合之后的结果进行处理，在这种处理中，udf函数也是一种常见的处理方式。<br>比如，我们将上述Dataframe根据gender聚合后，计算每种年龄人群的平均年龄。我们可以通过内建函数和udf函数分别计算，来说明udf函数在这种情况下的使用方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 注册udf函数</span><span class="token keyword">def</span> <span class="token function">avg_age</span><span class="token punctuation">(</span>ages<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>ages<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ages<span class="token punctuation">)</span>udf_avg_age <span class="token operator">=</span> f<span class="token punctuation">.</span>udf<span class="token punctuation">(</span>avg_age<span class="token punctuation">,</span> DoubleType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 2. 对group数据进行处理</span>df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'gender'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>agg<span class="token punctuation">(</span>    f<span class="token punctuation">.</span>avg<span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>alias<span class="token punctuation">(</span><span class="token string">'in_avg_func'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    udf_avg_age<span class="token punctuation">(</span>f<span class="token punctuation">.</span>collect_list<span class="token punctuation">(</span>f<span class="token punctuation">.</span>col<span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>alias<span class="token punctuation">(</span><span class="token string">'udf_avg_func'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>输出结果：<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230327200604.png" alt="输出结果"></li></ul>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spark</tag>
      
      <tag>udf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive-join操作优化</title>
    <link href="/2023/03/20/spark/Hive-join%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96/"/>
    <url>/2023/03/20/spark/Hive-join%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Join是Hive SQL操作中极为常见的一种，常出现在两个表处理数据的过程中互相关联的操作过程。<br>Join操作也是Hive SQL中经常出现问题的一种操作，最常见的问题就是出现较为严重的数据倾斜，导致运行时间远超预期；或者是出现了笛卡尔积，导致输出的数据量和预期的数据量不一致。</p><h3 id="Join的tedia能"><a href="#Join的tedia能" class="headerlink" title="Join的tedia能"></a>Join的tedia能</h3><ol><li>只支持等值连接</li><li>底层处理的时候会将Hive SQL的代码转换成MapReduce过程，而且Reduce过程会按照join的过程从左到右（除最后一个表外）对涉及到的表进行缓存</li><li>当三个或者是更多个表进行join时，如果每个on使用相同的字段连接，只会产生一个MapReduce</li></ol><h3 id="Join优化的几条方法"><a href="#Join优化的几条方法" class="headerlink" title="Join优化的几条方法"></a>Join优化的几条方法</h3><ol><li>合理设置map和reduce的数量<ul><li>设置map数目<br><code>set mapred.reduce.tasks=10;</code></li><li>设置reduce数目<br><code>set mapred.reduce.tasks = 15;</code><br><code>set hive.exec.reducers.bytes.per.reducer=500000000; （500M）</code></li></ul></li><li>对于没有相互依赖关系的阶段可以通过并行执行任务进行加速<br><code>set hive.exec.parallel=true</code></li><li>使用left semi join替代IN，EXIST等操作<br>left semi join 是 IN、EXIST的一种高效实现<ul><li>示例： <figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">select a.key, a.value from awhere a.key in (select b.key in b)select a.key, a.value from aleft semi joinbon a.key &#x3D; b.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li><li>left semi join右边的表只能在on中设置过滤条件，不能在select子句中设置</li><li>left semi join的select结果只能出现左边表的值</li><li>left semi join的on条件遇到右边表存在重复值的情况，遇到第一条就会结束</li></ul></li><li>当使用多个表进行join的时候，注意join的顺序<br>join的表从左到右应该是从小表到大表。<br>因为Hive在进行操作的时候会把其他表都缓存起来，直到join的最后一个表</li><li>小表进行join的时候使用mapjoin<br>为了加速计算，可以将小表先缓存起来。<ol><li>自动缓存 <figure><div class="code-wrapper"><pre class="line-numbers language-hive" data-language="hive"><code class="language-hive">set hive.auto.convert.join&#x3D;true; 是否开启自动将小于设置值的表进行缓存set hive.mapjoin.smalltable.filesize&#x3D;300000000;     可以进行缓存的表的最大值，300000000，即30Mset hive.auto.convert.join.noconditionaltask&#x3D;true;  是否将多个mapjoin合成一个set hive.auto.convert.join.noconditionaltask.size&#x3D;300000000;    多个mapjoin转换为1个时，所有小表的文件大小总和的最大值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li><li>手动缓存 <figure><div class="code-wrapper"><pre class="line-numbers language-hive" data-language="hive"><code class="language-hive">select  &#x2F;*+ mapjoin(x)*&#x2F;  x.a,  y.b from t_x x join t_y y on x.id&#x3D;y.id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ol></li><li>jion中的数据亲写处理<figure><div class="code-wrapper"><pre class="line-numbers language-hive" data-language="hive"><code class="language-hive">set hive.optimize.skewjoin&#x3D;true;set hive.skewjoin.key&#x3D;100000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spark</tag>
      
      <tag>hive</tag>
      
      <tag>join</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下进行字符截断</title>
    <link href="/2023/03/08/linux/linux%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD/"/>
    <url>/2023/03/08/linux/linux%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>在日常的操作中，我们经常会遇到需要对字符串进行截断的操作，如果是在python中可以直接通过对string的index进行筛序获得想要的子字符串。<br>那么，在shell命令行中，有没有类似的操作方法呢？答案是有的，而且有多种实现方法~</p><h2 id="1-变量截取"><a href="#1-变量截取" class="headerlink" title="1. 变量截取"></a>1. 变量截取</h2><blockquote><p>这种方法，可以在使用变量的时候进行快速截取，非常类似python中的a[:1]的使用方法。</p></blockquote><p><strong>使用方法如下</strong>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">'1234567890'</span><span class="token comment"># sub_str=$&#123;str: start_index: length&#125;</span><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">:</span> 3<span class="token operator">:</span> 4&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>str: 需要被截断的字符串</li><li>start_index：起始index，注意在这里使用的时候index是从0开始的</li><li>length：需要截取的长度</li></ul><h4 id="1-1-省略写法"><a href="#1-1-省略写法" class="headerlink" title="1.1 省略写法"></a>1.1 省略写法</h4><ol><li><p>省略起始位置</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">:</span> <span class="token operator">:</span>4&#125;</span><span class="token builtin class-name">echo</span> <span class="token variable">$sub_str</span><span class="token comment"># 1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>省略起始位置的话，相当于默认从0开始阶段</p></li><li><p>省略长度</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">:</span> 7&#125;</span><span class="token builtin class-name">echo</span> <span class="token variable">$sub_str</span><span class="token comment"># 890</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>省略截断长度的额话，相当于从指定位置截取到字符串末尾</p></li></ol><h4 id="1-2-从右边开始计数"><a href="#1-2-从右边开始计数" class="headerlink" title="1.2 从右边开始计数"></a>1.2 从右边开始计数</h4><p>如果想从字符串的右边开始计数，对字符串进行阶段的话，可以使用如下操作方式：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># sub_str=$&#123;str: 0-start_index: length&#125;</span><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">:</span> 0-3<span class="token operator">:</span> 2&#125;</span><span class="token builtin class-name">echo</span> <span class="token variable">$sub_str</span><span class="token comment"># 89</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>注意, 相较从左边开始计数，start_index, length含义不变。</li><li>但是start_index前面多了<code>0-</code>字符，这是固定写法，专门用来标明从字符串右边开始计数</li><li>PS：从右边开始计数的时候字符的index是从1开始的，和默认从左边开始不一样，需要额外注意</li></ul><h4 id="1-3-从指字符开始"><a href="#1-3-从指字符开始" class="headerlink" title="1.3 从指字符开始"></a>1.3 从指字符开始</h4><ol><li>根据指定字符截取右边子串<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">#</span>*7&#125;</span><span class="token builtin class-name">echo</span> <span class="token variable">$sub_str</span><span class="token comment"># 890</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>如果你的字符串中包含多个需要匹配的字符，上面的匹配方法会输出从第一个字符开始到结尾的子串。<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"12732723"</span><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">#</span>*7&#125;</span><span class="token builtin class-name">echo</span> <span class="token variable">$sub_str</span><span class="token comment"># 32723</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>虽然当前方法无法指定具体从哪个字符开始，但是提供了一种从最后一个匹配到的字符开始截取的方法，如下：<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"12732723"</span><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">##</span>*7&#125;</span><span class="token builtin class-name">echo</span> <span class="token variable">$sub_str</span><span class="token comment"># 23</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li><li>根据指定字符截取左边子串<br>同样，通过指定字符匹配的方法，也可以从左侧开始，不过指定的格式变成了<code>%chars*</code><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"12732723"</span><span class="token assign-left variable">sub_str</span><span class="token operator">=</span><span class="token variable">$&#123;str<span class="token operator">%</span>7*&#125;</span><span class="token builtin class-name">echo</span> <span class="token variable">$sub_str</span><span class="token comment"># 12732</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ol><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>${str: start_index: length}</td><td>从str左边第start_index个字符开始，向右边截取length个字符</td></tr><tr><td>${str: start_index}</td><td>从str左边第start_index个字符开始，截取到str末尾</td></tr><tr><td>${str: 0-start_index: length}</td><td>从str右边第start_index个字符开始，向右边截取length个字符</td></tr><tr><td>${str: 0-start_index}</td><td>从str右边第start_index个字符截取到str末尾</td></tr><tr><td>${str#*chars}</td><td>从str中第一次出现chars的位置开始，截取到str末尾</td></tr><tr><td>${str##*chars}</td><td>从str中最后一次出现chars的位置开始，截取到str末尾</td></tr><tr><td>${str%chars*}</td><td>从str右边开始算起，第一次出现chars开始（即str左边起最后一次出现chars），截取chars左边的所有字符</td></tr><tr><td>${str%%chars&amp;}</td><td>从str右边开始算起，最后一次出现chars开始（即str左边起第一次出现chars），截取chars左边所有字符</td></tr></tbody></table><h2 id="2-cut函数"><a href="#2-cut函数" class="headerlink" title="2. cut函数"></a>2. cut函数</h2><p>上面通过变量进行截取不太方便进行进一步的操作，只能赋给一个新的变量。为了方便处理，也可以使用cut函数进行处理。<br>cut命令可以从文件的每一行对字节、字符、字段进行处理，并将处理后的结果写到标准输出。<br>如果不指定file参数的话，cut可以读取标准输入。<br><strong>常用使用方法</strong>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cut</span> <span class="token punctuation">[</span>-bn<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token function">cut</span> <span class="token punctuation">[</span>-c<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token function">cut</span> <span class="token punctuation">[</span>-df<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>-b: 以字节为单位进行分割。注意，这些字节位置会忽略多字节的字符边界</li><li>-c：以字符为单位进行分割</li><li>-d：自定义分隔符，模人物制表符</li><li>-f：与-d一起使用，指定显示哪个区域</li><li>-n：取消分割多个字节字符。仅和-b一起使用</li></ul><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">'1234567890'</span><span class="token builtin class-name">echo</span> <span class="token variable">$str</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-c</span> <span class="token number">7</span><span class="token comment"># 7，输出第7个字符</span><span class="token builtin class-name">echo</span> <span class="token variable">$str</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-b</span> <span class="token number">1</span>-7<span class="token comment"># 1234567，输出第1到第7个字符</span><span class="token comment"># 注意：cut的序号从1开始，而且不会忽略右侧的index</span><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">'12t34t56t78'</span><span class="token builtin class-name">echo</span> <span class="token variable">$str</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">'t'</span> <span class="token parameter variable">-f2</span><span class="token comment"># 34</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>string</tag>
      
      <tag>cut</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transformer常见面试题</title>
    <link href="/2023/02/24/MachineLearning/transformer%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/02/24/MachineLearning/transformer%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>transformer是现在面试过程中常见的一类问题，这里简单记录一下，方便后续查找。</p></blockquote><ul><li>transformer基本结构<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230301085826.png" alt="transformer基本结构"></li></ul><ul><li>transformer更新公式<br>$$<br>\begin{align}<br>&amp;\left{<br>\begin{array}{lr}<br>Q_i &amp;&#x3D; QW^{Q}_i \\<br>K_i &amp;&#x3D; KW^{K}<em>i &amp; i&#x3D;1,\cdots,8\\<br>V_i &amp;&#x3D; VW^{V}</em>{i} \\<br>\end{array}<br>\right. \\<br>&amp;head_i &#x3D; Attention(Q_i, K_i, V_i), i&#x3D;1,\cdots,8 \\<br>&amp;MultiHead(Q, K, V) &#x3D; Concat(head_1, \cdots, head_8)W^O<br>\end{align}<br>$$</li></ul><ol><li><p>Transformer为何使用多头注意力机制？（为什么不使用一个头）<br> 使用多头是为了是参数空间形成多个子空间，在每个子空间上进行self-attention之后，可以分别捕获到当前子空间维度的信息<br> 同时对矩阵整体而言size不变，从而可以产生计算量不变但是能够学习到特征多维度信息的效果</p></li><li><p>Transformer为什么Q和K使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？ （注意和第一个问题的区别）</p></li><li><p>Transformer计算attention的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？</p></li><li><p>为什么在进行softmax之前需要对attention进行scaled（为什么除以dk的平方根），并使用公式推导进行讲解</p></li><li><p>在计算attention score的时候如何对padding做mask操作？</p></li><li><p>为什么在进行多头注意力的时候需要对每个head进行降维？（可以参考上面一个问题）</p></li><li><p>大概讲一下Transformer的Encoder模块？</p></li><li><p>为何在获取输入词向量之后需要对矩阵乘以embedding size的开方？意义是什么？</p></li><li><p>简单介绍一下Transformer的位置编码？有什么意义和优缺点？</p></li><li><p>你还了解哪些关于位置编码的技术，各自的优缺点是什么？</p></li><li><p>简单讲一下Transformer中的残差结构以及意义。</p></li><li><p>为什么transformer块使用LayerNorm而不是BatchNorm？LayerNorm 在Transformer的位置是哪里？</p></li><li><p>简答讲一下BatchNorm技术，以及它的优缺点。</p></li><li><p>简单描述一下Transformer中的前馈神经网络？使用了什么激活函数？相关优缺点？</p></li><li><p>Encoder端和Decoder端是如何进行交互的？（在这里可以问一下关于seq2seq的attention知识）</p></li><li><p>Decoder阶段的多头自注意力和encoder的多头自注意力有什么区别？（为什么需要decoder自注意力需要进行 sequence mask)</p></li><li><p>Transformer的并行化提现在哪个地方？Decoder端可以做并行化吗？</p></li><li><p>简单描述一下wordpiece model 和 byte pair encoding，有实际应用过吗？</p></li><li><p>Transformer训练的时候学习率是如何设定的？Dropout是如何设定的，位置在哪里？Dropout 在测试的需要有什么需要注意的吗？</p></li><li><p>引申一个关于bert问题，bert的mask为何不学习transformer在attention处进行屏蔽score的技巧？</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>machine-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine-learning</tag>
      
      <tag>transformer</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>召回算法演进-1</title>
    <link href="/2023/02/24/RecommendSystem/%E6%9E%B6%E6%9E%84/%E5%8F%AC%E5%9B%9E/%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B-1/"/>
    <url>/2023/02/24/RecommendSystem/%E6%9E%B6%E6%9E%84/%E5%8F%AC%E5%9B%9E/%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B-1/</url>
    
    <content type="html"><![CDATA[<p>召回，推荐系统的奠基者，拍脑袋的集大成者，业务效果的画线者。他决定了你最终能看到的内容的最大集合，他也决定了这次展示的业务体验。<br>假设你是一名推荐系统的开发工程师，经过了几天几夜的爆肝后，第一版的推荐算法终于上线了。这时候，产品找了过来，“不行啊，结果里没有最近上新的产品啊，会影响后续ROI的。老板要求必须有新品的。”你想反驳却又没办法，只能想办法在结果中尽量恰当的显示新品。但是怎么做呢？新品没有足够的行为数据，很难出现在最后的推荐结果中。正在一筹莫展的时候，旁边一个老员工给你除了个主意，“插一路新品的召回进去吧！”<br>没错，在推荐系统里召回的实践中，多路召回是常用的策略。也就是有多种不同的处理逻辑分别生成一路召回结果分别解决指定的一个问题，最后融合在一起作为召回结果。正因为这个原因，召回几乎称得上是推荐系统的流程中最丰富多彩的过程。</p><p>常见的召回算法通常分成非个性化召回和个性化召回两种，而在非个性化和个性化下面又有各种需求带来的不同算法。下面，我们按照在推荐系统的部署实现过程中，召回算法比较常见的上线过程进行一些常见召回算法的介绍。</p><h1 id="非个性化召回"><a href="#非个性化召回" class="headerlink" title="非个性化召回"></a>非个性化召回</h1><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230228191313.png" alt="常见非个性化召回方法"></p><p>非个性化召回通常由策略组成，比如热度、新品、精品···，经常是为了保证业务性的策略而实现。这些方法大多不和用户的信息绑定。比如，现在的新闻信息流中，最top的几条通常是近期热点、时事、政策等，和用户无关，但是非常的重要。这些通过是通过人工或者某些既定的策略维护在一个制定的池子中，根据具体的需求情况进行展示。</p><h1 id="1-热度召回"><a href="#1-热度召回" class="headerlink" title="1. 热度召回"></a>1. 热度召回</h1><p>第一种，也是在推荐系统前期上线的过程中最容易铺开的一种，热度召回算法。<br>这种召回算法实质上是一个存储在实时数据库中的倒排索引。这里倒排索引的value是待筛选的商品ids，key则是召回过程中需要使用到的索引query。其中倒排索引的value中的商品按照当前要求的热度召回指标的顺序从高到低进行排序，排序的结果就是在这一路召回中需要的顺序。</p><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230228191254.png" alt="热度召回"></p><p>热度召回算法的思路很简单，就是按照当前的需求指标对商品进行简单的排序筛选，将满足筛选条件的商品集合进行召回展示。实现过程很简单，直接使用一定时间窗内的商品指标的统计结果即可。以ctr指标为例，对应的统计指标通常如下：</p><p>$$<br>\begin{align}<br>ctr &amp;&#x3D; \frac{click_cnt}{expose_cnt} \tag{1}\\<br>corr_ctr &amp;&#x3D; \frac{click_cnt + corr_click_cnt}{expose_cnt + corr_expose_cnt} \tag{2}\\<br>corr_ctr_2 &amp;&#x3D; weight_1 * hour_1(corr_ctr) + weight_2 * hour_2(corr_ctr) + \dots \tag{3}<br>\end{align}<br>$$</p><p>如上，针对最基础的ctr统计方法有两种优化策略。<br>第二种相对第一种主要解决了新品因为曝光量少而存在的商品ctr统计值存在一些偏差的问题，通过分子分母的校验，保证新品或者是曝光量较少的商品的统计ctr指标能够保持在一个比较稳定的位置上，而不会因为统计偏差导致倒排列表的前面被大量的新品或曝光量少的商品占据，而挤压了真正优质的商品的存活空间。<br>第三种方法通过时间衰减的策略，保证了热度召回的策略对实时热度商品的快速反应，能够保证在最近一段时间内出现爆款的商品可以较好的出现在召回商品中，而不容易被前期的结果影响。同时这种策略可以对新品和上线时间较长但因为质量不佳而曝光量较少的商品进行一些区分。</p><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230228191321.png" alt="统计指标计算方法"></p><p>常见的热度召回除了以ctr为排序指标外，还可以使用cvr等深层指标进行排序从而实现针对不同质量商品的过滤逻辑。</p><h1 id="2-其他用途"><a href="#2-其他用途" class="headerlink" title="2. 其他用途"></a>2. 其他用途</h1><p>同样，可以通过调整不同的倒排指标实现对召回商品的质量调整，常用的召回通道如下：</p><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230228191328.png"><br>新品上架时间召回：将商品按照上架时间进行倒排，主要为了解决新品因为没有足量的行为数据，导致在排序层较难获得曝光机会的问题。<br>上下文相关性召回：主要使用在搜索场景或者是相关性推荐场景上。<br>指定商品召回：主要是为了除了一些拥有特权的商品的召回，尤其是在新闻场景下，某些特殊新闻的召回需求。</p>]]></content>
    
    
    <categories>
      
      <category>recommend-system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>recommend-system</tag>
      
      <tag>struct</tag>
      
      <tag>recall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-blog中配置个人简历</title>
    <link href="/2023/02/24/blog/hexo-blog%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <url>/2023/02/24/blog/hexo-blog%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>近期在整理个人简历的时候，突发奇想，准备将我自己的简历放到github-pages上部署的blog里。所以就研究了一下如何在hexo中配置个人简历，一番折腾下来，确实配好了，但是却达不到完全通过markdown就可以实现我想要的效果。<br>最终的结果就是在markdown里面增加了许多的html相关的配置，才达到了一个简单的效果。<br>折腾过程就记录在这里，方便后续查阅吧。</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src='https://raw.githubusercontent.com/ZermZhang/pictures/main/20230224085327.png' width=40% alt="简历效果"><h1 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h1><p>为了实现我想要的简历效果，最主要的难点在于如何通过markdown控制简历中各类型信息的排版问题，最常见的方法就是通过表格。但是markdown中的表格无法自由的控制单元格宽度和表格宽度，最终只能通过空单元格解决。</p><h3 id="1-1-表格排版"><a href="#1-1-表格排版" class="headerlink" title="1.1 表格排版"></a>1.1 表格排版</h3><blockquote><p>通过空单元格对信息排版进行控制</p></blockquote><ul><li><p>正常的单元格配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token table"><span class="token table-header-row"><span class="token punctuation">|</span><span class="token table-header important">name1</span><span class="token punctuation">|</span><span class="token table-header important">name2</span><span class="token punctuation">|</span></span><span class="token table-line"><span class="token punctuation">|</span><span class="token punctuation">---</span><span class="token punctuation">|</span><span class="token punctuation">---</span><span class="token punctuation">|</span></span><span class="token table-data-rows"><span class="token punctuation">|</span><span class="token table-data">age1</span><span class="token punctuation">|</span><span class="token table-data">age2</span><span class="token punctuation">|</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><table><thead><tr><th>name1</th><th>name2</th></tr></thead><tbody><tr><td>age1</td><td>age2</td></tr></tbody></table></li><li><p>具有空单元格的表格</p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">|name1||name2||---|---|--||age1||age2|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><table><thead><tr><th>name1</th><th></th><th>name2</th></tr></thead><tbody><tr><td>age1</td><td></td><td>age2</td></tr></tbody></table></li><li><p>通过增加一个空单元格的方法，可以让简历中的信息不用都聚集在屏幕的左侧，但是当前表格的边框影响了么美观，为了将单元格的边框去掉，只好通过当前页面的自定义style信息配置实现。</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css"><span class="token selector">td, th, tr</span> <span class="token punctuation">&#123;</span>   <span class="token property">border</span><span class="token punctuation">:</span> none<span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在文档的开始部分增加如上配置，可以使当前页面的所有表格隐藏边框，提升信息排版的美观度。<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230224085040.png" alt="无边框表格"></p></li></ul><h3 id="1-2-图标配置"><a href="#1-2-图标配置" class="headerlink" title="1.2 图标配置"></a>1.2 图标配置</h3><p>在上面的简历图片中可以看到使用了很多的矢量图图标，提升了简体整体的丰富度。因为我觉着再web端不需要像纸质简历那么严肃，可以加一些有趣的东西在里面，所以我在简历中将本来用文字描述的部分增加了一些图标。<br>在图标的选择上，可以根据个人喜好来定，常见的iconfont、makrdown-emoji都可以，我这里选用了<a href="https://fontawesome.com/search">font-awesome</a>来用，因为我觉这款图标比较符合我的审美，而且使用简单。</p><ul><li>使用方法：<figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li>在文档开始部分增加如上配置，就可以在文档里随时使用font-awesome的矢量图标<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230224091017.png" alt="font-awesome图标"><br>将图中的html标签复制下来，就可以在文档里显示了，就像这样<i class="fa-solid fa-house"></i></li></ul><h1 id="2-增加页面"><a href="#2-增加页面" class="headerlink" title="2. 增加页面"></a>2. 增加页面</h1><p>在hexo中增加简历页面有两种方法：</p><ol><li>正常的把简历当成一个普通文档插入到blog中</li><li>把简历当做一个独立页面配置到blog中</li></ol><h3 id="2-1-正常插入"><a href="#2-1-正常插入" class="headerlink" title="2.1 正常插入"></a>2.1 正常插入</h3><p>正常插入的方法很简单，直接在<code>_posts</code>文件夹下你指定的位置建一个存放简历markdown文档的位置即可。<br>但是这样的配置方法会面临一个麻烦的问题——无法再你希望的位置进行展示，为了解决这个问题，只好在一些常见页面上配置通过简历页面的超链接，比如配置在about页面上：<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230224093242.png" alt="指向resume页面的超链接"><br>这里要注意超链接的配置方法：</p><ol><li>最简单的配置方法当然是将blog发布后复制简历页面的web端超链接配置，但是当你调整了页面或者是blog的一些配置后就有可能会影响到当前超链接的位置导致失效。</li><li>另外一种相对比较稳定的方法就是配置简历页面在blog里的相对位置，这里推荐大家看一下hexo生成页面的逻辑。<br>当你通过<code>hexo g</code>生成blog的时候，hexo会根据你的文章元信息生成文章对应的html的存储位置，主要信息就是<code>date</code>这个参数，比如你文章的配置是<code>date: 2022-02-22</code>，那么你的文章就会存储在<code>/public/2022/02/22/</code>文件夹下面。<br>如果你同时在元信息中也配置了<code>categories</code>信息，比如<code>categories: [&#39;resume&#39;]</code>，那么生成的文章就会存储在<code>/public/2022/02/22/resume/</code>下面<br>那么你配置的超链接只要是<code>$&#123;date&#125;/$&#123;categories&#125;/$&#123;title&#125;</code>就好了，注意<code>public</code>不需要配置</li></ol><h3 id="2-2-独立配置"><a href="#2-2-独立配置" class="headerlink" title="2.2 独立配置"></a>2.2 独立配置</h3><p>独立配置就是在<code>source</code>文件夹下生成一个独立文件夹，将resume文档放到这个文件夹下，这样做的好处是更自由。<br>注意，默认独立文件夹下的文档的正文没有markdown样式，为了实现和文章相同的样式的话，需要增加如下配置：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>markdown-body<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>正文<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="3-结束"><a href="#3-结束" class="headerlink" title="3. 结束"></a>3. 结束</h1><p>好了，如何在hexo下配置个人简历的方法是记好了，如果你也感兴趣的话，可以自己动手试一下了。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>blog</tag>
      
      <tag>resume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resume</title>
    <link href="/2023/02/22/resume/resume/"/>
    <url>/2023/02/22/resume/resume/</url>
    
    <content type="html"><![CDATA[<style>td, th, tr {   border: none!important;}</style><!-- <head>    <script defer src="https://use.fontawesome.com/releases/v5.15.4/js/all.js"></script>    <script defer src="https://use.fontawesome.com/releases/v5.15.4/js/v4-shims.js"></script></head>  --><!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"> --><!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.css"> --><!-- 简历说明表头 --><table><thead><tr><th align="left"><h1>XXX</h1></th><th><div style="width:300px"></th><th><img src='/images/avatar/avatar.PNG' style="border-radius: 50%; width: 30%"></th></tr></thead></table><!-- 个人信息部分 --><h2 id="个人信息"><a href="#个人信息" class="headerlink" title=" 个人信息"></a><i class="fa-solid fa-user"></i> 个人信息</h2><table><thead><tr><th align="left"><i class="fa-solid fa-mars"></i>: 男</th><th><div style="width:200px"></th><th align="left"><i class="fa-solid fa-school-flag"></i>: 南京大学</th></tr></thead><tbody><tr><td align="left"><i class="fa-solid fa-phone"></i>: 198-xxxx-xxxx</td><td></td><td align="left"><i class="fa-solid fa-envelope"></i>: <a href="mailto:&#x78;&#120;&#120;&#x78;&#x78;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109;">&#x78;&#120;&#120;&#x78;&#x78;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109;</a></td></tr><tr><td align="left"><i class="fa-solid fa-briefcase"></i>: 算法工程师</td><td></td><td align="left"><i class="fa-solid fa-yen-sign"></i>: xxx</td></tr></tbody></table><!-- 教育、工作经历介绍 --><h2 id="教育-工作经历"><a href="#教育-工作经历" class="headerlink" title=" 教育&#x2F;工作经历"></a><i class="fa-solid fa-graduation-cap"></i> 教育&#x2F;工作经历</h2><table><thead><tr><th align="left"></th><th><div style="width:20%"></th><th align="left"></th><th><div style="width:20%"></th><th align="left"></th><th><div style="width:20%"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">希音</td><td></td><td align="left">2018.10 ~ 至今</td><td><div style="width:20%"></td><td align="left">搜索、推荐</td><td><div style='width:20%'></td><td align="left">资深算法工程师</td></tr><tr><td align="left">腾讯</td><td></td><td align="left">2016.07 ~ 2018.10</td><td></td><td align="left">游戏广告、短视频推荐</td><td></td><td align="left">算法工程师</td></tr><tr><td align="left">南京大学</td><td></td><td align="left">2013.09 ~ 2016.07</td><td></td><td align="left">计算数学</td><td></td><td align="left">研究生</td></tr><tr><td align="left">SDNU</td><td></td><td align="left">2009.09 ~ 2013.06</td><td></td><td align="left">计算数学</td><td></td><td align="left">本科</td></tr></tbody></table><!-- 项目经历 --><h2 id="项目经历"><a href="#项目经历" class="headerlink" title=" 项目经历"></a><i class="fa-solid fa-folder"></i> 项目经历</h2><h3 id="项目1"><a href="#项目1" class="headerlink" title="项目1"></a>项目1</h3><blockquote><p>公司, 时间段，收益</p></blockquote><ol><li>背景</li><li>工作内容</li><li>收益详情说明</li></ol><h3 id="项目2"><a href="#项目2" class="headerlink" title="项目2"></a>项目2</h3><blockquote><p>公司，时间段，收益</p></blockquote><ol><li>背景</li><li>工作内容</li><li>收益详情说明</li></ol>]]></content>
    
    
    <categories>
      
      <category>resume</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>综述</title>
    <link href="/2023/01/16/RecommendSystem/%E7%BB%BC%E8%BF%B0/%E7%BB%BC%E8%BF%B0/"/>
    <url>/2023/01/16/RecommendSystem/%E7%BB%BC%E8%BF%B0/%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/image-20230116193855105-3869205.png" alt="基本结构"><br>大家在平常的生活中，肯定经历过刷手机刷到停不下来的时候，最常见的就是在刷淘宝、抖音、小红书的时候，那么你有没有考虑过是什么原因导致你拿起手机就放不下呢？这篇文章主要就是为了探讨这些策略背后的秘密，让你了解到到底有多少人为了你在他们的app上花掉更多时间而努力着。</p><h2 id="1-什么是推荐系统？"><a href="#1-什么是推荐系统？" class="headerlink" title="1. 什么是推荐系统？"></a>1. 什么是推荐系统？</h2><p>现在常提到的推荐系统其实是一种基于个性化的信息过滤系统。</p><p>那么这里就会出现两个问题：</p><ol><li><p>什么是 个性化？</p></li><li><p>为什么要进行 信息过滤？</p></li></ol><p>我们先解释为什么要进行<strong>信息过滤。</strong></p><p>这里一个难以避免的概念是<strong>信息过载</strong>(information overload)。这个词是Alvin Toffler在1970年于他的著作Future Shock中创造出来的。通常是指接受太多信息，反而影响正常的理解和决策。</p><p>信息的形式载体从最初原始部落时代的象形文字，笔画等，随着科技的发展，逐步经历羊皮纸，纸张等，最终升级到现代的互联网。技术的升级降低了信息创造和传递的成本，同时带来了信息数量级的爆炸性增长。面临每天都在暴涨的互联网信息，如何找到用户真正感兴趣或者是对用户真正有用的信息就变成了一件极负挑战性的任务。与此同时，推荐系统和搜索引擎应运而生，当然，我们这里主要集中在推荐系统的介绍上。</p><p>然后我们介绍一下为什么需要<strong>个性化</strong>。</p><p>不知道大家有没有关注过国内网民人均app每日使用时长对比的情况，下图来自于极光的行业研究报告。为什么要在这里提到app的使用时长呢？因为在用户存量的时期，用户时长决定了最终的变现能力。为了达到这个目标，运营、产品、营销都在朝这个方向努力着。</p><p>那么个性化推荐系统在这个方向上的发力点在哪里呢？最直观的方向就是通过个性化的内容展示拉起用户的兴趣，不断地拉高用户在当前app上的用户黏性，从而实现掠夺用户可用的碎片化时间的目的。说到这里，你有没有发现和你在抖音、快手等短视频上的体会比较相似，本来说好了刷20min就睡觉的，结果刷着刷着，2个小时就过去了。</p><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/image-20230117084201668.png" alt="移动网民人均app每日使用时长top8"></p><p>接下来，我会从常见的个性化推荐系统的结构出发，结合我几年来在推荐系统上的工作经验，谈一谈我个人对个性化推荐系统的看法和理解。一家之言，如有缺漏之处，欢迎大家补充。</p><h2 id="2-线下的推荐系统是什么样的？"><a href="#2-线下的推荐系统是什么样的？" class="headerlink" title="2. 线下的推荐系统是什么样的？"></a>2. 线下的推荐系统是什么样的？</h2><p>想必大家都听过尿布与啤酒的故事，这是关联分析的一个经典案例。</p><p>据说超市经常会将啤酒和婴儿的尿不湿放在比较接近的地方，原因是从销售小票上发现经常会有人在超市购买尿布的时候顺手拿一瓶啤酒。这样就可以显著的提升啤酒的销售量。</p><p>这个例子就是线下的推荐系统的典型表现，对线下的商超来说，因为物理空间的原因，商品的展示空间有限，不可能将商品的种类进行无限量的增加，所以解决类似推荐问题的办法比较简单，通过留存的销售小票就可以分析出相关性很高的商品种类，从而实现关联销售的目的。但是线上推荐的时候会有这么简单么？</p><p>当然不会，在互联网的场景下，不存在物理空间的限制，商品的展示空间成本被无限压缩，与之对应的，可展示的被商品数目也会爆炸性的增长，这种情况下如何给用户展示可能引起他兴趣的内容便成为了一个系统性的问题，个性化推荐系统的主要目标也就是为了解决这个问题。</p><h2 id="3-线上的推荐系统是什么样的？"><a href="#3-线上的推荐系统是什么样的？" class="headerlink" title="3. 线上的推荐系统是什么样的？"></a>3. 线上的推荐系统是什么样的？</h2><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/image-20230117084350927.png" alt="推荐系统基本结构"></p><h3 id="推荐系统的整体结构简述"><a href="#推荐系统的整体结构简述" class="headerlink" title="推荐系统的整体结构简述"></a>推荐系统的整体结构简述</h3><p>推荐系统一般包括四个主要环节，分别是召回(recall)，粗排(pre-rank)，精排(rank)和重排(re-rank)。</p><p>不同的部分在整个推荐系统中扮演的角色都不尽相同，</p><ul><li>召回(recall): 负责从庞大的商品集合中选出用户可能感兴趣的子集</li><li>粗排(pre-rank): 对召回选择出的商品子集进行初排序，选出用户可能最喜欢的topN的商品，主要为了给精排降低压力</li><li>精排(rank): 基于粗排提供的侯选池对商品进行兴趣偏好的排序</li><li>重排(re-rank): 将奖牌返回的结果进行重新排序，常见的是用来处理一些业务需求</li></ul><h4 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h4><p>从上面四个环节来看，召回处在整个推荐系统的入口处，决定了有哪些备选的商品可以流入到推荐系统中，天然决定了推荐系统所能达到的上限。自然，从效果的目的来说，召回的目的是能尽量多的召回用户感兴趣的商品，但是实际的使用过程中，存在着难以避免的商品体验性的问题，因此，召回同事还需要考虑和上下文的相关性问题。</p><p>同时，召回层面对的输入是十万、百万、甚至更多的商品集合，所以线上使用的时候对这一部分的复杂度和耗时情况都比较敏感。因此，召回层所使用的的特征、模型、策略都不会太复杂，通过相对后续的排序层较少的特征或规则实现对被选集的快速筛选，减少后续排序的耗时情况。同时，排序层考虑的目标通常比较单一，比如ctr、cvr等，这是，召回层就可以通过多路召回的方式进行一些热度、时效等方向的召回，增加推荐系统最终输出结果的多样性，防止陷入信息茧房中。</p><h4 id="粗排"><a href="#粗排" class="headerlink" title="粗排"></a>粗排</h4><p>粗排层嵌在召回和精排之间，起到的是承前启后的作用，主要目的是为了降低精排的压力。</p><p>经过了召回的筛选之后，商品备选集的数目从10e5<del>6降到了10e4</del>5，但是这个量级的商品对精排来说话排序压力依旧存在，所以需要通过粗排对它们进行一次简略的排序，这次排序并不需要强调排序在商品粒度上的准确性，而是要实现尽量排序序列的topN的准确性。</p><p>粗排的桥接作用就体现在了topN准确性的保证上，如果无法正常的进行筛选，后续的精排就很难实现更优的排序结果，如果粗排能够实现商品粒度的准确排序的话，那和精排就没有功能上的区别了。</p><h4 id="精排"><a href="#精排" class="headerlink" title="精排"></a>精排</h4><p>精排是推荐系统各层级中最纯粹的一层，他的目标比较单一且集中，一门心思的实现目标的调优即可。最开始的时候精排模型的常见目标是ctr,后续逐渐发展了cvr等多类目标。但是现在比较常见的优化指标还是ctr比较多。</p><p>精排和粗排层的基本目标是一致的，都是对商品集合进行排序，但是和粗排不同的是，精排只需要对少量的商品(即粗排输出的商品集合的topN)进行排序即可。因此，精排中可以使用比粗排更多的特征，更复杂的模型和更精细的策略（用户的特征和行为在该层的大量使用和参与也是基于这个原因）。这一个模块也是现在各位从业任务从事最多，竞争最激烈的模块，大部分和推荐系统相关的论文最初可能都是在精排层上取得的效果然后进行了逐步的推广。</p><p>从这里也可以看出，粗排和精排的区分并没有那么的泾渭分明，如果精排可以在一次请求中完全吞下所有的商品集合，其实是不需要粗排的。</p><h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p>重排主要用来处理一些业务逻辑和策略，不过最近几年也有越来越多指向重排的模型化工作在进行。</p><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>这篇文章算是我对个性化推荐系统的各个模块的一个简单认知，后续会对各层中的详情和常用模型以及算法进行一个更深入的介绍，作为一个在工作生涯上走了一段时间的人的总结。</p>]]></content>
    
    
    <categories>
      
      <category>recommend-system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>recommend-system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown中使用流程图</title>
    <link href="/2022/11/30/blog/markdown%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2022/11/30/blog/markdown%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>markdown使我们在工作中常用的一种工具，可以极大的优化我们在文档编写方面的效率。</p><p>同样，流程图在日常工作中也是一件必不可少的利器。</p><p>那么有没有什么方法可以将这两种格式融合到一起进行处理呢？</p></blockquote><h2 id="1-mermaid介绍"><a href="#1-mermaid介绍" class="headerlink" title="1. mermaid介绍"></a>1. mermaid介绍</h2><blockquote><p>Meimaid是一个基于Javascript的图标绘制工具，通过解析类Markdown的文本语法来实现图表创还能和动态修改。</p><p>Mermaid诞生的主要目的是让文档的更新能够及时跟上开发的进度。</p></blockquote><p>上面是mermaid官方仓库对mermaid的介绍。</p><p>在我的日常使用中，可以很好的体会到mermaid在这一方面的努力，通过在markdown中集成mermaid，将之前繁琐的流程图绘制工作简化成了大家熟悉的类markdown语言编写过程，极大的方便了文档编写过程中的快速变更和方便阅读。</p><p><a href="https://github.com/mermaid-js/mermaid">mermaid官方仓库</a></p><h2 id="2-mermaid支持的图表类型"><a href="#2-mermaid支持的图表类型" class="headerlink" title="2. mermaid支持的图表类型"></a>2. mermaid支持的图表类型</h2><table><thead><tr><th>图表类型</th><th>关键字</th></tr></thead><tbody><tr><td>流程图</td><td>flowchart</td></tr><tr><td>时序图</td><td>sequenceDiagram</td></tr><tr><td>甘特图</td><td>gantt</td></tr><tr><td>类图</td><td>classDiagram</td></tr><tr><td>状态图</td><td>stateDiagram</td></tr><tr><td>饼图</td><td>pie</td></tr><tr><td>Git图</td><td>gitGraph</td></tr><tr><td>用户体验旅程图</td><td>journey</td></tr><tr><td>C4图</td><td>C4Context</td></tr></tbody></table><h2 id="3-mermaid使用示例"><a href="#3-mermaid使用示例" class="headerlink" title="3. mermaid使用示例"></a>3. mermaid使用示例</h2><ul><li>通过如下代码可以直接在markdown中生成指定的流程图</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">flowchart LRa<span class="token punctuation">[</span>hard<span class="token punctuation">]</span> --<span class="token operator">>|</span>relation<span class="token operator">|</span> b<span class="token punctuation">(</span>Round<span class="token punctuation">)</span>b --<span class="token operator">></span> c<span class="token punctuation">&#123;</span>Decision<span class="token punctuation">&#125;</span>c --<span class="token operator">></span> D<span class="token variable"><span class="token punctuation">((</span>result <span class="token number">1</span><span class="token punctuation">))</span></span> <span class="token operator">&amp;</span> E<span class="token punctuation">[</span>result <span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/image-20221130181955501.png" alt="image-20221130181955501"></p><ul><li>说明：<ul><li><code>flowchart LR</code>: 通过flowchart声明需要生成流程图，LR代码图的走向为从左到右<ul><li>LR：从左（left）到右（right）</li><li>RL：从右（right）到左（left）</li><li>TB：从上（top）到下（bottom）</li><li>BT：从下（bottom）到上（top）</li></ul></li><li><code>a[hard]</code>：声明节点，节点名为a，<code>[hard]</code>表示当前节点为文本为hard的直角矩形框<ul><li><code>()</code>: 圆角矩形框</li><li><code>[]</code>: 直角矩形框</li><li><code>&#123;&#125;</code>：判断框</li><li><code>(())</code>：圆形框</li><li>当然，mermaid还支持很多其他类型的框图，具体可以参考<a href="https://mermaid-js.github.io/mermaid/#/flowchart">文档</a></li></ul></li><li><code>--&gt;</code>：节点之间的连接线</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>markdown</tag>
      
      <tag>流程图</tag>
      
      <tag>mermaid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spark.read的使用</title>
    <link href="/2022/08/31/spark/spark.read%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/31/spark/spark.read%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>spark在读取csv文件的时候，会涉及到许多参数，这些参数的作用各有不同，这里进行一个简单的介绍。</p></blockquote><h2 id="1-spark读取csv文件"><a href="#1-spark读取csv文件" class="headerlink" title="1. spark读取csv文件"></a>1. spark读取csv文件</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> spark<span class="token punctuation">.</span>read<span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">'csv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>option<span class="token punctuation">(</span><span class="token string">'sep'</span><span class="token punctuation">,</span> <span class="token string">'\t'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>schema<span class="token punctuation">(</span>schemas<span class="token punctuation">)</span><span class="token punctuation">.</span>load<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="2-option参数介绍"><a href="#2-option参数介绍" class="headerlink" title="2. option参数介绍"></a>2. option参数介绍</h2><table><thead><tr><th>参数</th><th>解释</th><th>默认值</th></tr></thead><tbody><tr><td>sep</td><td>读取文件内容后，对同一行内容实用该参数指定的分割符进行分割</td><td><code>,</code></td></tr><tr><td>encoding</td><td>解码方式</td><td><code>utf-8</code></td></tr><tr><td>quote</td><td>通过当前配置值包裹的内容，不通过sep进行分割</td><td><code>&quot;</code></td></tr><tr><td>escape</td><td>当quote字符内部还有quote字符时，可以通过当前字符进行转义</td><td><code>\</code></td></tr><tr><td>header</td><td>是否将文件的第一行作为列名</td><td><code>false</code></td></tr><tr><td>inferSchema</td><td>从数据进行schema推断</td><td><code>false</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spark</tag>
      
      <tag>read</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据基本介绍</title>
    <link href="/2022/08/25/RecommendSystem/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/08/25/RecommendSystem/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>数据在推荐系统的任务中是重中之重，不光是推荐系统，在整个深度学习体系中，“garbage in，garbage out”都是从业者的金科玉律。<br>所以，数据处理永远都是ai从业者在日常工作中难以忽略的一项极为重要的工作内容。</p></blockquote><h1 id="1-数据构成"><a href="#1-数据构成" class="headerlink" title="1. 数据构成"></a>1. 数据构成</h1><p>推荐系统的数据构成相较其他的nlp、cv等机器学习领域，具有自己独特的特点，因为推荐系统的数据是来自于用户在前端的行为实时产生的数据，所以这些数据天然是具有标注的性质的。比如，用户发生了点击的行为大概率是要优于用户看过但是没有点击的item的，用户收藏的item大概率是要优于只是点进来看了看的item的。<br>那么，我们要怎么样才能将用户在前端的行为恰当的表现在数据中呢？这就是在构建推荐系统的特征的时候极为重要，也极为困难的一个部分了。<br>这涉及到了数据的基本构成和我们在数据生成的过程中需要注意到的方方面面的内容。<br>这里，我们先简单介绍一下推荐系统数据的基本构成情况。</p><h2 id="1-1-特征"><a href="#1-1-特征" class="headerlink" title="1.1 特征"></a>1.1 特征</h2><p>推荐系统中，不可或缺的三个部分是用户(user)，物品(item), 环境(context)。<br>这三者构成了推荐系统下的整体循环。<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230214091440.png" alt="推荐系统三者关系"><br>这三者的循环构成了整个推荐系统数据中必不可少的三类特征，而在日常使用中，这三类特征也是最常见，最需要先入手的三类特征。<br>针对这三类特征的介绍，在下问题<a href="#2.1">根据不同来源进行分类</a>中进行详细介绍。</p><h2 id="1-2-行为漏斗"><a href="#1-2-行为漏斗" class="headerlink" title="1.2 行为漏斗"></a>1.2 行为漏斗</h2><p>行为漏斗是推荐系统数据构建过程中必不可缺的一个部分。因为这部分信息天然的将我们需要的特征做好了正负样本的区分。<br>在线上推荐系统环境下，用户的行为漏斗根据具体场景不同分成了曝光、点击、收藏、加车、购买、不喜欢、屏蔽等等信息。当然，我们最常用是下面几种：<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230220200419.png" alt="常见漏斗数据"></p><h4 id="曝光："><a href="#曝光：" class="headerlink" title="曝光："></a>曝光：</h4><p>曝光特征行为在线上推荐系统中，是必然会发生的一种行为。<br>当用户出现在我们的环境下，曝光的行为就已经发生了。这种行为是推荐系统数据中最基础也是最大量的组成部分。</p><h4 id="点击："><a href="#点击：" class="headerlink" title="点击："></a>点击：</h4><p>点击行为使用户在线上环境中自主发生的一种正向行为，这种行为代表了用户对当前物品的感兴趣的程度要高于其他没有发生点击行为的物品，是推荐系统重常用的正样本来源之一。</p><h1 id="2-特征"><a href="#2-特征" class="headerlink" title="2. 特征"></a>2. 特征</h1><p>推荐系统的特征有多种分类方式，包括根据不同的来源进行分析，根据生成逻辑进行分类等等。</p><h2 id="2-1-根据不同来源进行分类"><a href="#2-1-根据不同来源进行分类" class="headerlink" title="2.1 根据不同来源进行分类"></a>2.1 根据不同来源进行分类</h2><p>根据不同的来源进行分类主要是从特征的生成方来区分特征，这是特征天然的区分方式，而且是大部分推荐系统环境下必然可以进行的分类方案。<br>根据这种方法，可以将特征分成用户，物品，环境（也叫上下文）三大类。</p><h3 id="2-1-1-上下文特征"><a href="#2-1-1-上下文特征" class="headerlink" title="2.1.1 上下文特征"></a>2.1.1 上下文特征</h3><p>上下文特征主要是指用户在推荐系统的环境下发生行为时的环境信息。从这一段描述中我们可以看出，上下文特征其实也可以分成两大类，其一：时间上下文特征；其二：空间上下文特征。</p><h4 id="时间上下文特征"><a href="#时间上下文特征" class="headerlink" title="时间上下文特征"></a>时间上下文特征</h4><ul><li>热门物品的相关时间</li><li>季节属性的影响</li><li>商品生命周期</li><li>用户兴趣变化</li><li>站点、环境的生命周期变更</li></ul><h4 id="空间上下文特征"><a href="#空间上下文特征" class="headerlink" title="空间上下文特征"></a>空间上下文特征</h4><ul><li>行为发生的位置<ul><li>站点页面展示位置</li><li>具体的物理空间位置（ip、经纬度等等）</li></ul></li><li>行为发生时的环境信息<ul><li>当前页面的关联信息</li><li>当前页面的具体位置</li><li>用户来到当前页面前的行为路径</li><li>···</li></ul></li></ul><h3 id="2-1-2-物品特征"><a href="#2-1-2-物品特征" class="headerlink" title="2.1.2 物品特征"></a>2.1.2 物品特征</h3><p>物品特征主要指的是能够从各个角度对商品进行恰当描述的信息和特征。<br>通过这些描述，我们能够对物品有一个基础的认知，能够通过当前认知将不同的商品进行区分，同时又能够将具体相同信息的物品有一个鉴别的逻辑。</p><ul><li>物品的标题</li><li>物品的描述信息</li><li>物品的类目表述</li><li>物品的各类统计特征</li><li>物品的图像</li><li>物品的作者、提供商</li><li>···</li></ul><h3 id="2-1-3-用户特征"><a href="#2-1-3-用户特征" class="headerlink" title="2.1.3 用户特征"></a>2.1.3 用户特征</h3><p>用户特征和物品特征类似，主要是为了对当前系统面对的用户进行多维度的区分和认知。<br>同时，因为用户是行为的主动发起方，同时也是推荐系统中的重中之重，所以为了能够清晰的认知到不同用户之间的区别，恰当的构造用户特征也是特征构造过程中极为重要的一点。为了完成这种需求，用户特征需要从各个方面进行构造和处理。</p><ul><li>用户基础描述（用户的年龄、性别等基本信息）</li><li>用户的兴趣偏好</li><li>用户的兴趣变化</li></ul><h2 id="2-2-根据生成逻辑进行分类"><a href="#2-2-根据生成逻辑进行分类" class="headerlink" title="2.2 根据生成逻辑进行分类"></a>2.2 根据生成逻辑进行分类</h2><h3 id="2-2-1-单值特征"><a href="#2-2-1-单值特征" class="headerlink" title="2.2.1 单值特征"></a>2.2.1 单值特征</h3><p>单值特征，指的是一般情况下的离散特征，多是来自于一些环境和用户的静态特征，比如用户的性别，当前网络状态是否是wifi等等。<br>这一类特征相对而言比较简单，因为取值唯一，多用<code>1</code>来表示该特征存在，用<code>0</code>表示该特征不存在。</p><h3 id="2-2-2-多值特征"><a href="#2-2-2-多值特征" class="headerlink" title="2.2.2 多值特征"></a>2.2.2 多值特征</h3><p>多值特征是相对单值特征而言，特征项的取值部分有多个选项的特征，该类特征在上线文特征、物品特征、用户特征里都有存在，是推荐系统中较为常见的特征类型。比如：当前网页环境的页面标识，用户的年龄段、物品的标题、描述等等。<br>多值特征在使用过程中很难直接利用，因为伴随着特征生成过程中可能存在的各种问题，多值特征开会存在不同的缺失、异常等问题。随之衍生的针对特征的处理技巧也是推荐系统特征工程中的一大难题。</p><h3 id="2-2-3-统计值特征"><a href="#2-2-3-统计值特征" class="headerlink" title="2.2.3 统计值特征"></a>2.2.3 统计值特征</h3><p>统计值大多是从原始特征基础上经过数数学统计之后得到的一些数值类特征，这些特征能够很好的展示某个基础特征的指定维度组合信息，能够给到模型很好的先验信息。</p><h3 id="2-2-4-序列特征"><a href="#2-2-4-序列特征" class="headerlink" title="2.2.4 序列特征"></a>2.2.4 序列特征</h3><p>序列特征大多是和用户的行为强绑定在一起的一种特征信息。这一类特征表示了用户的近期兴趣变化情况。</p>]]></content>
    
    
    <categories>
      
      <category>recommend-system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>recommend-system</tag>
      
      <tag>datas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见optimizers梳理</title>
    <link href="/2022/07/29/MachineLearning/%E5%B8%B8%E8%A7%81optimizers%E6%A2%B3%E7%90%86/"/>
    <url>/2022/07/29/MachineLearning/%E5%B8%B8%E8%A7%81optimizers%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>optimzer是在机器学习算法中的核心部分，针对常见的optimizer的具体实现原理和公式进行深入了解后，可以对使用模型训练过程中的问题分析有明显的帮助。</p></blockquote><h1 id="1-优化器基本思路"><a href="#1-优化器基本思路" class="headerlink" title="1. 优化器基本思路"></a>1. 优化器基本思路</h1><p>常见的优化器基本都是通过梯度下降（Gradient Descent）的方法对模型的参数进行更新，使根据损失函数在测试集合上的损失值逐步降低，从而达到优化模型的目的。<br>这里按照常见优化器的更新和提出过程对他们的基本原理和更新公式进行一个梳理和备份。<br>在本文中可能会用的标记：<br>$$<br>\begin{align}<br>&amp; \theta_{t}: 在时刻t的模型参数   \\<br>&amp; \alpha: optimizer更新过程中的学习率   \\<br>&amp; J: 损失函数 \\<br>&amp; g_{t} &#x3D; \frac{\partial J(\theta_{t})}{\partial \theta_{t}} &#x3D; \nabla_{\theta}J(\theta): 在时刻t，损失函数相对\theta_{t}的导数 \\<br>&amp; \beta: 加权平均的权重<br>\end{align}<br>$$</p><h1 id="2-常见优化器"><a href="#2-常见优化器" class="headerlink" title="2. 常见优化器"></a>2. 常见优化器</h1><h2 id="2-1-随机梯度下降（SGD）"><a href="#2-1-随机梯度下降（SGD）" class="headerlink" title="2.1 随机梯度下降（SGD）"></a>2.1 随机梯度下降（SGD）</h2><p>SGD是最传统、最基础的模型优化方法。</p><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><ul><li>在小批量的数据集上计算损失函数的梯度从而对模型的权重进行迭代更新。</li></ul><h3 id="更新公式"><a href="#更新公式" class="headerlink" title="更新公式"></a>更新公式</h3><p>$$<br>\theta_{t} &#x3D; \theta_{t-1} - \alpha * g(\theta_{t-1})<br>$$</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>过程简单，但是相对而言收敛速度可能比较慢</li><li>每次更新时产生的梯度方向可能会产生较大的变化，从而导致更新方向的震荡，而陷入到局部最优点中。<ol><li>更新过程中，batch的大小会影响到本次梯度的稳定性</li></ol></li></ol><h2 id="2-2-动量优化方法（Momentum）"><a href="#2-2-动量优化方法（Momentum）" class="headerlink" title="2.2 动量优化方法（Momentum）"></a>2.2 动量优化方法（Momentum）</h2><p>为了优化传统的SGD可能存在的更新方向震荡的问题，该方法在权重更新的过程中增加了针对梯度的累计动量的概念。<br>针对梯度的累积方法，这里采用了指数加权平均的逻辑，主要是为了对时间序列上的梯度赋予不同的权重，如下公式：<br>$$<br>\begin{align}<br>v_t &#x3D; &amp; \beta v_{t-1} + (1 - \beta)g_t \\<br>    &#x3D; &amp; \beta(\beta v_{t-2} + (1-\beta)g_{t-1}) + (1-\beta)g_{t} \\<br>    &amp; \dots \\<br>    &#x3D; &amp; (1-\beta)(\beta^t g_0 + \beta^{t-1}g_1 + \dots + \beta g_{t-1} + g_t)<br>\end{align}<br>$$<br>通过如上公式处理，越靠近当前时间的梯度，它的权重越接近1，越远离当前时间的梯度，它的权重越接近0，这样既保证了能够累积过去时间的梯度情况，又能一定程度上保证靠近当前时间的梯度带来的影响。<br>最积累了足够优化步数的梯度之后，如果本次使用的梯度优化方向出现了较大的震荡，那么在梯度的累积值的影响下，会对本次优化方向进行较为明显的矫正，以消除抖动。</p><h3 id="更新公式-1"><a href="#更新公式-1" class="headerlink" title="更新公式"></a>更新公式</h3><p>$$<br>\begin{align}<br>v_t &#x3D; &amp; \beta v_{t-1} + (1-\beta) * g(\theta_{t-1}) \\<br>\theta_t &#x3D; &amp; \theta_{t - 1} - \alpha * v_t<br>\end{align}<br>$$</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>对更新过程的梯度进行了动量累积处理，对于和整体梯度方向一致的参数可以加速学习，对于和整体的梯度方向相反的参数可以降低更新次数。因此，该方法可在相关性更高的方向上进行加速学习，从而减少震荡、加速收敛过程</li><li>同样是因为对梯度进行了累积，所以在后面的更新过程中，$v_t$会逐渐变大，如果学习率$\alpha$设置不好的话，会导致后期更新过程不容易完全熟练到最优点的情况。</li></ol><h2 id="2-3-自适应梯度下降（Adgrad）"><a href="#2-3-自适应梯度下降（Adgrad）" class="headerlink" title="2.3 自适应梯度下降（Adgrad）"></a>2.3 自适应梯度下降（Adgrad）</h2><p>Adgrad算法解决了因为梯度不断积累导致学习率不能很好的适应参数更新过程的问题。<br>在更新过程中，先将$g_t^2$全部记录下来，用来对当前次获取到的梯度更新方向的震荡进行矫正；然后，通过将累积下来的梯度平方作为分母对学习率进行调整。<br>在更新前期，梯度累积量较小，平滑之后的学习率依旧比较大，可以在一定程度上放大梯度，加速更新。<br>在更新后期，梯度累积量变大，平滑之后的学习率较小，可以在一定程度上缩小梯度，防止更新过程出现最优点附近的震荡。</p><h3 id="更新公式-2"><a href="#更新公式-2" class="headerlink" title="更新公式"></a>更新公式</h3><p>$$<br>\begin{align}<br>v_t &#x3D; v_{t-1} + g_t^2 \\<br>h_t &#x3D; \frac{\alpha}{v_t + \epsilon}g_t \\<br>\theta_t &#x3D; \theta_{t-1} - h_t<br>\end{align}<br>$$</p><h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><ol><li>增加了学习率的自适应调整逻辑，可以根据更新过程自动调整学习率大小，根据情况获取不同的参数更新状态。</li><li>因为梯度平方的累积一直在进行当中，后期可能会导致学习率被平滑到极小，导致收敛过程缓慢。</li></ol><h2 id="2-4-RMSprop"><a href="#2-4-RMSprop" class="headerlink" title="2.4 RMSprop"></a>2.4 RMSprop</h2><p>RMSprop算法结合了Adagrad和Momentum的优点，同时拥有了学习率自适应调整和梯度累积量根据时间序列调整的优点。<br>从下文的更新公式中可以看出，RMSprop的更新过程和Adagrad不同的地方在于对$g_t^2$进行累计的时候，没有使用简单直接的求和逻辑，而是使用了指数加权平均的逻辑。<br>这样，既保证了可以记录过去时间点上的$g_t$信息，也能保证累积下来的$v_t$不会出现无限增长的问题。</p><h3 id="更新公式-3"><a href="#更新公式-3" class="headerlink" title="更新公式"></a>更新公式</h3><p>$$<br>\begin{align}<br>v_t &amp;&#x3D; \beta v_{t-1} + (1 - \beta) g_t^2 \\<br>h_t &amp;&#x3D; \frac{\alpha}{v_t + \epsilon}g_t \\<br>\theta_t &amp;&#x3D; \theta_{t-1} - h_t<br>\end{align}<br>$$</p><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>使用指数加权平均对梯度累积过程进行了优化，防止在迭代后期对学习率$\alpha$进行过度的衰减，导致收敛过程缓慢。</li></ol><h2 id="2-5-Adam"><a href="#2-5-Adam" class="headerlink" title="2.5 Adam"></a>2.5 Adam</h2><p>Adam优化器结合了Adagrad和RMSprop两种优化器的优点，在对学习率更新的过程中考虑了梯度的一阶预估和二阶预估。</p><h3 id="更新公式-4"><a href="#更新公式-4" class="headerlink" title="更新公式"></a>更新公式</h3><p>$$<br>\begin{align}<br>m_t &amp;&#x3D; \beta_1\cdot m_{t-1} + (1-\beta_1)\cdot  g_t \\<br>v_t &amp;&#x3D; \beta_2\cdot v_{t-1} + (1-\beta_2)\cdot g_t^2 \\<br>\hat{m_t} &amp;&#x3D; \frac{m_t}{1-\beta_1^t} \\<br>\hat{v_t} &amp;&#x3D; \frac{v_t}{1-\beta_2^t} \\<br>\theta_t &amp;&#x3D; \theta_{t-1} - \alpha\cdot\frac{\hat{m_t}}{\sqrt{\hat{v_t}}+\epsilon}<br>\end{align}<br>$$</p><h2 id="2-6-FTRL"><a href="#2-6-FTRL" class="headerlink" title="2.6 FTRL"></a>2.6 FTRL</h2><h3 id="更新公式-5"><a href="#更新公式-5" class="headerlink" title="更新公式"></a>更新公式</h3><p>$$<br>\begin{align}<br>\end{align}<br>$$</p><h2 id="2-7-FTML"><a href="#2-7-FTML" class="headerlink" title="2.7 FTML"></a>2.7 FTML</h2><h3 id="更新公式-6"><a href="#更新公式-6" class="headerlink" title="更新公式"></a>更新公式</h3><p>$$<br>\begin{align}<br>\end{align}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>machine-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine-learning</tag>
      
      <tag>optimizer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tf.keras.Model研读</title>
    <link href="/2022/07/22/tensorflow/tensorflow%E7%A0%94%E8%AF%BB/tf.keras.Model%E7%A0%94%E8%AF%BB/"/>
    <url>/2022/07/22/tensorflow/tensorflow%E7%A0%94%E8%AF%BB/tf.keras.Model%E7%A0%94%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Model模块可以将Layer组合成具有针对特征的训练的推演功能的对象。</p></blockquote><h1 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h1><h2 id="1-1-输入参数"><a href="#1-1-输入参数" class="headerlink" title="1.1 输入参数"></a>1.1 输入参数</h2><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>inputs</td><td>模型的输入，可以是单个的<code>tf.keras.Input</code>也可以是一个由<code>tf.keras.Input</code>组成的List</td></tr><tr><td>outputs</td><td>模型的输出</td></tr><tr><td>name</td><td>模型的名称，string类型</td></tr></tbody></table><h2 id="1-2-使用方法"><a href="#1-2-使用方法" class="headerlink" title="1.2 使用方法"></a>1.2 使用方法</h2><h3 id="1-2-1-Functional-API"><a href="#1-2-1-Functional-API" class="headerlink" title="1.2.1 Functional API"></a>1.2.1 Functional API</h3><blockquote><p>将使用到的层按照模型前序的顺序构建好后，在最后从输入到输出构建需要的模型.</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tfinputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>x <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>outputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>laters<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>softmax<span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>model <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">(</span>inputs<span class="token operator">=</span>inputs<span class="token punctuation">,</span> outputs<span class="token operator">=</span>outputs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="1-2-2-SubClassing-API"><a href="#1-2-2-SubClassing-API" class="headerlink" title="1.2.2 SubClassing API"></a>1.2.2 SubClassing API</h3><blockquote><p>使用subclassing api的时候，可以在<code>__init__()</code>中定义将要使用到的layer，并在<code>call()</code>中定义模型的前馈逻辑.</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">class</span> <span class="token class-name">MyModel</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>softmax<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> trainging<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>dense1<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>        <span class="token keyword">if</span> training<span class="token punctuation">:</span>        <span class="token comment"># 通过training参数对训练和interface过程中的不同逻辑进行控制</span>            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>x<span class="token punctuation">,</span> training<span class="token operator">=</span>training<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dense2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    model <span class="token operator">=</span> MyModel<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h1><h2 id="2-1-call"><a href="#2-1-call" class="headerlink" title="2.1 call"></a>2.1 call</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">call(inputs, training&#x3D;None, mask&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>inputs</td><td>模型输入，可以是由tensor组成的dict&#x2F;list&#x2F;tuple</td></tr><tr><td>training</td><td>Boolean值，对网络是进行training或者是interface进行区分</td></tr><tr><td>mask</td><td>网络中可能会用到的mask</td></tr></tbody></table><h2 id="2-2-compile"><a href="#2-2-compile" class="headerlink" title="2.2 compile"></a>2.2 compile</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">compile(optimizer&#x3D;&#39;rmsprop&#39;,        loss&#x3D;None,        metrics&#x3D;None,        loss_weights&#x3D;None,        weighted_metrics&#x3D;None,        run_eagerly&#x3D;None,        steps_per_execution&#x3D;None,        jit_compile&#x3D;None,        **kwargs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>optimizer</td><td>优化器</td></tr><tr><td>loss</td><td>损失函数</td></tr><tr><td>metrics</td><td>评估指标</td></tr></tbody></table><h3 id="作用过程"><a href="#作用过程" class="headerlink" title="作用过程"></a>作用过程</h3>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>Model</tag>
      
      <tag>Module</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MISS</title>
    <link href="/2022/06/30/thesis/MISS/"/>
    <url>/2022/06/30/thesis/MISS/</url>
    
    <content type="html"><![CDATA[<h1 id="MISS"><a href="#MISS" class="headerlink" title="MISS"></a>MISS</h1><p>MISS是近期华为提出的一个应用在ctr预估任务上的多兴趣自监督学习插件，能简单的插入到现有的NN模型中，并有明显的效果提升（13.55%）。<br>文章见《<a href="https://arxiv.org/abs/2111.15068">MISS: Multi-Interest Self-Supervised Learning Framework for Click-Through Rate Prediction</a>》<br>该论文通过$Sample-Level\ Data\ Argumentation,\ Multi-Interest\ Data\ Argumentation,\ Interest\ view\ encoder,\ Contrastive\ Loss$等几个模块实现了用户兴趣粒度上的特征embedding的增强。从而解决了特征稀疏和特征噪音可能造成的问题。</p><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><h1 id="2-模型框架"><a href="#2-模型框架" class="headerlink" title="2. 模型框架"></a>2. 模型框架</h1><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20220718165421.png" alt="overview-for-MISS"></p><h2 id="2-1-样本粒度的数据增强"><a href="#2-1-样本粒度的数据增强" class="headerlink" title="2.1 样本粒度的数据增强"></a>2.1 样本粒度的数据增强</h2><blockquote><p>数据增强是MISS框架的第一步</p></blockquote><p>对来自于$\mathcal{B} &#x3D; {x_1, x_2, \dots, x_{|\mathcal{B}|}}$的任意一个样本$x$, 都可以通过增强函数等到两个不同的视角:<br>$$<br>\begin{align}<br>    &amp; &lt;h^1, h^2&gt; &#x3D; Aug^{s}(x) \\<br>    &amp; Aug^{s}(\cdot): the sample-level argumentation function \\<br>    &amp; &lt;h^1, h2&gt;: the pair of generated view<br>\end{align}<br>$$</p><ul><li>考虑到用户行为序列的多兴趣特征，MISS框架对每个样本，从特征和兴趣层面进行了自监督学习。</li></ul><h3 id="2-1-1-多兴趣数据增强"><a href="#2-1-1-多兴趣数据增强" class="headerlink" title="2.1.1 多兴趣数据增强"></a>2.1.1 多兴趣数据增强</h3><h4 id="MIE"><a href="#MIE" class="headerlink" title="MIE"></a>MIE</h4><p>首先，抽取用户的多兴趣表示</p><ul><li>直观方法：将用户行为序列通过商品类目进行直接划分</li><li>本文方法：基于CNN的多兴趣抽取器(multi-interest extractor network)</li></ul><p>$\tau &#x3D; MIE(x) &#x3D; {t_1, t_2, \dots, t_{|\tau|}}$</p><ul><li>$MIE(\cdot)$是多兴趣抽取器网络</li><li>$\tau$是用户兴趣表征的输出</li><li>$t_k$是第k个从x中抽取出来的兴趣表征</li></ul><p>MIE的主要作用是发现来自用户行为序列里的潜在兴趣。当前的MIE基于一个亲密性假设：产生自相同兴趣的用户行为在用户行为序列中更有可能处在相近的位置上。</p><h5 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h5><ol><li>使用CNN来抽取隐藏的兴趣表征，因为CNN能够较好的捕捉局部联系。<ul><li>RNN和self-attention也可以用，但是实际表现并不太好</li></ul></li><li>对所有的行为序列Embedding进行padding到相同的长度$L$上<br>$$<br>\begin{gathered}<br>C &#x3D; \begin{bmatrix}<br> e_{1,1} &amp; e_{1,2} &amp; \dots &amp; e_{1,L} \<br> e_{2,1} &amp; e_{2,2} &amp; \dots &amp; e_{2,L} \<br> &amp; \vdots \<br> e_{J,1} &amp; e_{J,2} &amp; \dots &amp; e_{J,L}<br> \end{bmatrix}<br>\end{gathered}<br>$$<ul><li>$C \in \mathbb{R}^{J \times L \times K}$</li><li>$J$: 序列型特征的数量</li><li>$L$: 每个序列型特征padding之后的长度</li><li>$K$: 每个序列型特征内的单个特征$e_{j,l}$对应的Embdding的维度</li></ul></li><li>根据时间轴维度的水平卷积对隐藏兴趣进行抽取<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20220719094128.png" alt="history-sequence"></li></ol><h3 id="2-1-2-兴趣层面编码"><a href="#2-1-2-兴趣层面编码" class="headerlink" title="2.1.2 兴趣层面编码"></a>2.1.2 兴趣层面编码</h3><h2 id="2-2-对比loss"><a href="#2-2-对比loss" class="headerlink" title="2.2 对比loss"></a>2.2 对比loss</h2>]]></content>
    
    
    <categories>
      
      <category>thesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine-learning</tag>
      
      <tag>Multi-Interest Self-Supervised</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>find命令的「七种武器」</title>
    <link href="/2022/06/23/linux/find%E5%91%BD%E4%BB%A4%E7%9A%84%E3%80%8C%E4%B8%83%E7%A7%8D%E6%AD%A6%E5%99%A8%E3%80%8D/"/>
    <url>/2022/06/23/linux/find%E5%91%BD%E4%BB%A4%E7%9A%84%E3%80%8C%E4%B8%83%E7%A7%8D%E6%AD%A6%E5%99%A8%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Linux find命令用来在指定目录下查找文件.<br>任何位于参数之前的字符串会被作为将要查找的目录.<br>通过find命令，我们可以方便的操作Linux下的各种目录和文件信息，是Linux使用者常用的命令之一.</p></blockquote><p>find命令使用极为频繁，而且使用方法多种多用，参数繁多，这里根据常用的一些条件列出7种常用的使用方法。</p><h1 id="1-按照名称查找"><a href="#1-按照名称查找" class="headerlink" title="1. 按照名称查找"></a>1. 按照名称查找</h1><p>按照名称查找是最常用的方法之一，也是最简单的方法。可以通过文件名或者是正则表达式的文件名进行文件的搜索。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./logs <span class="token parameter variable">-name</span> log.20220623   <span class="token comment"># 在logs目录下检索名字为log.20220623的文件/文件夹</span><span class="token function">find</span> ./logs <span class="token operator">!</span> <span class="token parameter variable">-name</span> log.20220623   <span class="token comment"># 反向查找，检索除了log.20220623之外的所有文件/文件夹</span><span class="token function">find</span> ./logs <span class="token parameter variable">-name</span> <span class="token string">"log*"</span>    <span class="token comment"># 正则表达式查找，检索所有符合“log*”的文件/文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="https://s2.loli.net/2022/06/23/Sp4YFzJ3R6emVch.png" alt="按照名称查找.png"><br>find命令可以通过<code>-name &lt;样式&gt;</code>对指定路径中符合样式的文件或者是文件夹进行查找，<code>&lt;样式&gt;</code>可以是一个具体的文件名字，也可以是正则表达式，极大的方便了查找过程。<br>而且，在使用<code>-name</code>参数时还可以通过<code>!</code>进行方向查找，可以过滤需要保留的信息。</p><h1 id="2-按照文件类型查找"><a href="#2-按照文件类型查找" class="headerlink" title="2. 按照文件类型查找"></a>2. 按照文件类型查找</h1><p>从上面的查找结果中可以看到, 除了列出了符合条件的文件之外，还会列出当前文件夹的名字，但是如果你需要在find命令后面通过管道符<code>|</code>增加针对文件的具体操作的话，被列出来的文件夹可能会成为一个阻碍。这个问题也可以简单的通过<code>-type</code>参数进行解决。<br><code>-type</code>参数可以通过指定文件类型，从而只对指定类型的文件进行检索。</p><ul><li>f 普通文件</li><li>l 符号连接</li><li>d 目录</li><li>c 字符设备</li><li>b 块设备</li><li>s 套接字</li><li>p FIFO</li></ul><p><img src="https://s2.loli.net/2022/06/23/GZRt1WIVbdcsDnh.png" alt="按照文件类型进行查找.png"><br>你看，增加了文件类型参数说明后，find结果中显示的就只有普通的文件了，文件夹的信息已经被过滤了。</p><h1 id="3-按照文件时间戳进行查找"><a href="#3-按照文件时间戳进行查找" class="headerlink" title="3. 按照文件时间戳进行查找"></a>3. 按照文件时间戳进行查找</h1><p>随着工作时长的增加，你的电脑上的内容肯定会越来越多，尤其是一些例行化的日志文件，当你需要对日志信息进行清理的时候，时间便是一个很好的帮手，那么该怎么通过时间戳信息对文件进行过滤呢？<br>find命令中可以通过UNIX&#x2F;Linux文件系统中三种不同的时间戳对文件进行操作和查找：</p><ul><li>访问时间（-atime&#x2F;天，-amin&#x2F;分钟）：用户最后一次访问该文件的时间</li><li>修改时间（-mtime&#x2F;天，-mmin&#x2F;分钟）：文件最后一次被修改的时间</li><li>变化时间（-ctime&#x2F;天，-cmin&#x2F;分钟）：文件元数据（所有权、位置、文件类型、权限设置等信息）最后一次被修改的时间。</li></ul><p>使用这类参数的时候，需要注意命令的详细配置。<br>具体时间长度分成三种使用规范：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-mmin</span> <span class="token number">2</span>     <span class="token comment"># 检索修改时间距离现在正好2min的文件</span><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-mmin</span> +2    <span class="token comment"># 检索修改时间距离现在超过2min的文件</span><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-mmin</span> <span class="token parameter variable">-2</span>    <span class="token comment"># 检索修改时间距离现在小于2min的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="https://s2.loli.net/2022/06/23/kqAC4Vd8pLiRYBH.png" alt="按照文件时间戳进行查找.png"></p><h1 id="4-按照所有者查找"><a href="#4-按照所有者查找" class="headerlink" title="4. 按照所有者查找"></a>4. 按照所有者查找</h1><p>这个功能很简单，就是通过<code>-user</code>对文件的所有用户进行指定，过滤指定用户创建的文件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-user</span> zhang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="5-按照目录层级检索"><a href="#5-按照目录层级检索" class="headerlink" title="5. 按照目录层级检索"></a>5. 按照目录层级检索</h1><p>当你要检索的路径存在多级目录的时候，你可以通过<code>-maxdepth</code>参数指定你需要检索的目录层级数目，减少不必要的检索过程。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-name</span> <span class="token string">'log.*'</span> <span class="token parameter variable">-maxdepth</span> <span class="token number">1</span>   <span class="token comment"># 在第一级目录中检索文件，没有显示./logs/logs1/下的文件</span><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-name</span> <span class="token string">'log.*'</span> <span class="token parameter variable">-maxdepth</span> <span class="token number">2</span>   <span class="token comment"># 在第一、第二级目录中检索文件，显示了./logs/logs1/下的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><img src="https://s2.loli.net/2022/06/23/km7BQAUufOYEj1Z.png" alt="按照目录层级检索.png"></p><h1 id="6-按照文件大小检索"><a href="#6-按照文件大小检索" class="headerlink" title="6. 按照文件大小检索"></a>6. 按照文件大小检索</h1><p>当你需要对占用空间较大的文件进行处理或者是检索大量的小文件的时候，<code>-size</code>参数就是派上用场的时候了。<br><code>-size</code>参数可以根据文件的大小进行配置，使用方法和根据时间检索类似，可以根据指定文件大小范围进行检索。<br>可以使用的文件大小单位：</p><ul><li>b：块（512字节）</li><li>c：字节</li><li>w：字（2字节）</li><li>k：1024字节</li><li>M：1024k</li><li>G：1024M<br><img src="https://s2.loli.net/2022/06/23/5Bv7VMwjocKANkI.png" alt="按照文件大小检索.png"></li></ul><h1 id="7-按照检索之后执行命令"><a href="#7-按照检索之后执行命令" class="headerlink" title="7. 按照检索之后执行命令"></a>7. 按照检索之后执行命令</h1><p>对文件检索结束后通常需要对结果进行进一步的操作，这个时候可以使用<code>| xargs</code>的命令，同样也可以使用find自带的<code>exec</code>参数。</p><ul><li>将指定的文件进行删除：<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-size</span> +1c <span class="token parameter variable">-exec</span> <span class="token function">rm</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li>将30天之外的文件移动到old目录中<figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-mtime</span> +30 <span class="token parameter variable">-exec</span> <span class="token function">cp</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> old <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><p>当然，你也可以通过<code>ok</code>进行上述操作，他和<code>exec</code>的区别主要在于他会给出提示，来确定是否继续进行响应的操作。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./logs <span class="token parameter variable">-type</span> f <span class="token parameter variable">-mtime</span> +30 <span class="token parameter variable">-ok</span> <span class="token function">rm</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h1><p>上面列出来的其中find命令常用的操作，是我在日常使用中用的比较多的，但是绝不是仅仅意味着find只有这七种操作，find的操作有很大的自由度，大家需要的时候可以自行检索。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-rebase-merge说明</title>
    <link href="/2022/06/20/git/git-rebase-merge%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/06/20/git/git-rebase-merge%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>git rebase和git merge是在git使用中常见的命令之二，而且这两个命令的功能较为相似，都是将不同的分支进行分支合并。<br>但是在日常使用中，git merge的使用频率要远高于git rebase，究其原因是git rebase的复杂性导致的。<br>这里简单的介绍一下我个人对git merge和git rebase两者之间的区别和使用过程中需要注意的相关事项。</p></blockquote><ul><li>注意，本文中的git状态大多是从下图的基础状态出发：<br><img src="https://s2.loli.net/2022/06/20/qpvS7xYAdVlbGiL.png" alt="git-base-status.png"></li></ul><h1 id="1-命令介绍"><a href="#1-命令介绍" class="headerlink" title="1. 命令介绍"></a>1. 命令介绍</h1><figure><div class="code-wrapper"><pre class="line-numbers language-git" data-language="git"><code class="language-git">git-merge - Join two or more development histories togethergit-rebase - Reapply commits on top of another base tip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>上述，是git文档中对于merge和rebase两个命令的介绍。</p><h1 id="2-git-merge"><a href="#2-git-merge" class="headerlink" title="2. git merge"></a>2. git merge</h1><p>显然，当需要处理两个或者是多个分支合并的时候，git merge是一个很自然的选项，但是通过merge处理的分支合并过程中，会增加一个不必要的history join commit.<br><img src="https://s2.loli.net/2022/06/20/r8Gn314UOCbkBgy.png" alt="git-merge.png"><br>如上图，git merge之后，会在现有c1、c2、c3的基础上，新增一个c4节点，该节点是在c2和c3基础上merge之后的内容。</p><h1 id="3-git-rebase"><a href="#3-git-rebase" class="headerlink" title="3. git rebase"></a>3. git rebase</h1><p>为了防止出现这个无意义的commit而引起不必要的conflict，rebase这时候就成为了一个不错的选项。<br>rebase的中文名叫做“变基”，（一个很符合github用途的名字:smile:），它的具体作用也和名字很一致：改变当前分支checkout的位置。<br>如上git-base-status图片中展示的样子，dev是在c1节点处从main分支上checkout出来，通过git rebase可以调整当前分支的checkout位置，从而实现类似merge的功能。</p><h2 id="3-1-git-rebase-on-main"><a href="#3-1-git-rebase-on-main" class="headerlink" title="3.1 git rebase (on main)"></a>3.1 git rebase (on main)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-git" data-language="git"><code class="language-git">git checkout maingit rebase devgit merge devgit branch -d dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ol><li>先checkout到main分支上</li><li>在main分支上对dev进行rebase，表示将main分支checkout的位置从c1调整到dev的节点，即c3上。<br>此时，main分支的路径变为：c1&lt;-c3&lt;-c2’</li><li>可以将dev再merge到main上，但是此时的merge不会影响到main分支的内容<br><img src="https://s2.loli.net/2022/06/20/spSLCrK7bfEIRw3.png" alt="git-rebase-on-main.png"></li></ol><h2 id="3-2-git-rebase-on-dev"><a href="#3-2-git-rebase-on-dev" class="headerlink" title="3.2 git rebase (on dev)"></a>3.2 git rebase (on dev)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-git" data-language="git"><code class="language-git">git rebase maingit checkout maingit merge devgit branch -d dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ol><li>直接在dev分支上对main进行rabse，表示将dev分支checkout的位置从c1调整到main的节点，即c2上。<br>此时，dev分支的路径变为：c1&lt;-c2&lt;-c3’</li><li>切换回main分支，再将dev分支merge到main分支上<br><img src="https://s2.loli.net/2022/06/20/GJS9n5sWBPTqhOm.png" alt="git-rebase-on-dev.png"></li></ol><h1 id="4-备注"><a href="#4-备注" class="headerlink" title="4. 备注"></a>4. 备注</h1><ol><li>因为rebase的作用会改变git的history，所以在使用过程中必须要注意，rebase涉及到的history不能存储在远程，否则会引起本地和远程的conflict</li><li>git rebase也可以通过参数<code>-i</code>来处理过多的commit信息，防止commit log太过杂乱</li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>命令</tag>
      
      <tag>rebase</tag>
      
      <tag>merge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tf.lookup研读</title>
    <link href="/2022/06/16/tensorflow/tensorflow%E7%A0%94%E8%AF%BB/tf.lookup%E7%A0%94%E8%AF%BB/"/>
    <url>/2022/06/16/tensorflow/tensorflow%E7%A0%94%E8%AF%BB/tf.lookup%E7%A0%94%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>tf.lookup模块就是tf的字典功能，方便在大量备选的元素中根据key进行快速筛选。</p></blockquote><h1 id="1-主要构成"><a href="#1-主要构成" class="headerlink" title="1. 主要构成"></a>1. 主要构成</h1><p>tf.lookup模块包含了5个class和1个Module. Module中包含两个实验性质的class.<br>同样，这几个class可以按照我们的使用习惯，简单的分成3类.</p><table><thead><tr><th>分类</th><th>Class</th><th>说明</th></tr></thead><tbody><tr><td>从tensor生成table</td><td>KeyValueTensorInitializer</td><td>根据k,v对生成table initializer</td></tr><tr><td>从tensor生成table</td><td>StaticHashTable</td><td>从table initializer生成可以检索的table</td></tr><tr><td>从tensor生成table</td><td>StaticVocabularyTable</td><td></td></tr><tr><td>从文件内容生成table</td><td>TextFileInitializer</td><td></td></tr><tr><td>从文件内容生成table</td><td>TextFileIndex</td><td></td></tr><tr><td>先生成可变table</td><td>MutableHashTable</td><td></td></tr><tr><td>先生成可变table</td><td>DenseHashTable</td><td></td></tr></tbody></table><h1 id="2-从tensor生成table"><a href="#2-从tensor生成table" class="headerlink" title="2. 从tensor生成table"></a>2. 从tensor生成table</h1><p>通过现有的tensor生成可以检索的table，需要提供现成的key，val数据，经过KeyValueTensorInitializer生成init后，便可以通过StaticHashTable或StaticVocabularyTable生成table。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">keys_tensor <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>vals_tensor <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>input_tensor <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>init <span class="token operator">=</span> tf<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>KeyValueTensorInitializer<span class="token punctuation">(</span>keys_tensor<span class="token punctuation">,</span> vals_tensor<span class="token punctuation">)</span>table <span class="token operator">=</span> tf<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>StaticHashTable<span class="token punctuation">(</span>    init<span class="token punctuation">,</span>    default_value<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>input_tensor<span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># array([ 7, -1], dtype=int32)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>备注：</p><ol><li>keys, vals可以式tensor，也可以是普通的list，在init处理过程中会进行convert_to_tensor</li><li>检索过程中（table.lookup），输入的input_tensor必须是tensor，因为在检索过程中会进行type的检验<ul><li>如果声明init的时候使用python array，同时没有显式的声明dtype的时候，模型的dtype是tf.string</li></ul></li></ol><h1 id="3-从文件内容生成table"><a href="#3-从文件内容生成table" class="headerlink" title="3. 从文件内容生成table"></a>3. 从文件内容生成table</h1><p>当你有一个有&lt;key, val&gt;格式组成文件的时候，也可以通过tf自带的api将文件里的内容直接生成可以检索的table数据。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>NamedTemporaryFile<span class="token punctuation">(</span>delete<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>content<span class="token operator">=</span><span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"emerson 10"</span><span class="token punctuation">,</span> <span class="token string">"lake 20|"</span><span class="token punctuation">,</span> <span class="token string">"palmer 30"</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>init1<span class="token operator">=</span> tf<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>TextFileInitializer<span class="token punctuation">(</span>   filename<span class="token operator">=</span>f<span class="token punctuation">.</span>name<span class="token punctuation">,</span>   key_dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>string<span class="token punctuation">,</span>   key_index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>   value_dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>string<span class="token punctuation">,</span>   value_index<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>   delimiter<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>table1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>StaticHashTable<span class="token punctuation">(</span>init1<span class="token punctuation">,</span> default_value<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>table1<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'palmer'</span><span class="token punctuation">,</span><span class="token string">'lake'</span><span class="token punctuation">,</span><span class="token string">'tarkus'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># array([b'30', b'20|', b''], dtype=object)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="4-生成可变table"><a href="#4-生成可变table" class="headerlink" title="4. 生成可变table"></a>4. 生成可变table</h1><p>上述api都需要通过预先提供的数据生成一个固定的table，没有遇到过的key，只能通过default_value进行取值。<br>这种table相对比较死板，mutable_table解决的就是这种问题，可以生成一个能够随时增加元素的table，使用更便捷，更接近原始的python-array。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">table <span class="token operator">=</span> tf<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>MutableHashTable<span class="token punctuation">(</span>key_dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>string<span class="token punctuation">,</span>                                                value_dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>int64<span class="token punctuation">,</span>                                                default_value<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>keys_tensor <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>vals_tensor <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>int64<span class="token punctuation">)</span>input_tensor <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>keys_tensor<span class="token punctuation">,</span> vals_tensor<span class="token punctuation">)</span>table<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>input_tensor<span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># array([ 7, -1])   注意这里的输出，'f'因为检索不到对应的值，只能返回-1的默认值</span>new_keys <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>new_vals <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>int64<span class="token punctuation">)</span>table<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>new_keys<span class="token punctuation">,</span> new_vals<span class="token punctuation">)</span>table<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>input_tensor<span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># array([7, 3])     增加了元素'f'之后，可以正常的检索到对应的val了</span>table<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>input_tensor<span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># array([-1,  3])   删除了元素'a'之后，因为检索不到'a'的值，只能返回-1的默认值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>Module</tag>
      
      <tag>lookup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>airflow使用技巧</title>
    <link href="/2022/05/31/airflow/airflow%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/05/31/airflow/airflow%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要针对airflow的一些简单的使用技巧进行归纳总结，方便记录。</p></blockquote><h1 id="1-复杂Variable的使用"><a href="#1-复杂Variable的使用" class="headerlink" title="1. 复杂Variable的使用"></a>1. 复杂Variable的使用</h1><p>Variables是airflow中一个用来存储和重载自定义变量的功能，可以极大的简化针对dag中可能用到的变量信息。<br>最常用的方式就是在Variables中存储某一个值，需要的时候可以通过<code>var = Variable.get(&quot;my_var&quot;)</code>进行获取。<br>但是当你需要使用到复杂个是的variable的时候，上述逻辑就会遇到问题。比如：<br><img src="https://s2.loli.net/2022/05/31/mNxLnk6pqbrOdQu.png" alt="airflow-variables"><br>这个时候，针对变量<code>example_variables_config</code>的使用就需要使用json进行导入，导入方法如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">dag_config <span class="token operator">=</span> Variable<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"example_variables_config"</span><span class="token punctuation">,</span> deserialize_json<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>var1 <span class="token operator">=</span> dag_config<span class="token punctuation">[</span><span class="token string">"var1"</span><span class="token punctuation">]</span>var2 <span class="token operator">=</span> dag_config<span class="token punctuation">[</span><span class="token string">"var2"</span><span class="token punctuation">]</span>var3 <span class="token operator">=</span> dag_config<span class="token punctuation">[</span><span class="token string">"var3"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="2-airflow的时间说明"><a href="#2-airflow的时间说明" class="headerlink" title="2. airflow的时间说明"></a>2. airflow的时间说明</h1><blockquote><p>airflow中存在多种时间信息，包括dag开始时间、结束时间、调度时间等<br>比较容易产生混乱</p></blockquote><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20230417133930.png" alt="image.png"><br>如上图：</p><ul><li>Run：dag的调度时间，即execution_date，注意该时间相较当前的执行时间会早一个调度周期</li><li>Started：dag的启动时间，即当前dag启动时的系统时间</li><li>Ended：dag的结束时间，即当前dag运行结束时的系统时间</li></ul><p><strong>时间获取方法：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">execution_date <span class="token operator">=</span> <span class="token string">"&#123;&#123; execution_date &#125;&#125;"</span> <span class="token comment"># yyyymmdd</span>execution_date <span class="token operator">=</span> <span class="token string">"&#123;&#123; ds &#125;&#125;"</span> <span class="token comment"># yyyy-mm-dd</span>execution_date <span class="token operator">=</span> <span class="token string">"&#123;&#123; ds_nodash &#125;&#125;"</span> <span class="token comment"># yyyymmdd</span>beijing_today <span class="token operator">=</span> <span class="token string">"&#123;&#123; (macros.datetime.utcnow() + macros.timedelta(hours=8)).strftime('%Y-%m-%d %H') &#125;&#125;"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>airflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>airflow</tag>
      
      <tag>trick</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SENet</title>
    <link href="/2022/05/23/thesis/SeNet/"/>
    <url>/2022/05/23/thesis/SeNet/</url>
    
    <content type="html"><![CDATA[<h1 id="SENet"><a href="#SENet" class="headerlink" title="SENet"></a>SENet</h1><p>SENet是在文章《<a href="https://arxiv.org/abs/1709.01507">Squeeze-and-Excitation Networks</a>》中提出来的，原本的作用是为了在对图片中不同channel的关系进行建模，从而实现提升神经网络表达的作用。这种过程在文中被称作是特征矫正，即通过学习全局信息，从而有选择的强化有效信息，打压无效信息。</p><h1 id="1-SEBlock-结构"><a href="#1-SEBlock-结构" class="headerlink" title="1. SEBlock 结构"></a>1. SEBlock 结构</h1><p><img src="https://s2.loli.net/2022/05/23/ODs4HpBNIlF8Cog.png" alt="SEBlock结构"><br>上图是SEBlock的基本结构，清晰的展示了SEBlock主要由Squeeze和Excitation两部分组成。</p><ul><li><p>Squeeze结构<br>  $$z_c &#x3D; F_{sq}(u_c) &#x3D; \frac{1}{H\times W}\sum_{i&#x3D;1}^{H}\sum_{j&#x3D;1}^{W}u_{c}(i, j)$$</p><ul><li>通过指定维度，对特征进行聚合，产生channel上的描述</li><li>原文中的squeeze结构是通过一个平均函数生成的，计算每个channel上的embedding信息的平均值，作为当前channel的代表</li></ul></li><li><p>Excitation结构<br>  $$<br>  \begin{align}<br>  &amp; s &#x3D; F_{ex}(z, W) &#x3D; \sigma(g(z, W)) &#x3D; \sigma(W_{2}\delta(W_{1}z))  \tag{1} \\<br>  &amp; W_{1} \in\mathbb{R}^{\frac{C}{r}\times C} \quad and \quad W_{2} \in \mathbb{R}^{C \times \frac{C}{r}}  \tag{2} \\<br>  &amp; \quad \\<br>  &amp; x_c &#x3D; F_{scale}(\textbf{u}_c, s_c) &#x3D; s_c\textbf{u}_c \tag{3}<br>  \end{align}<br>  $$</p><ul><li>通过一个简单的门机制来计算每个channel对应的权重信息</li><li>为了捕捉每个通道的依赖关系，学习的函数需要满足两个条件：<ol><li>必须是可伸缩的，必须能够学习两个channel之间的非线性关系</li><li>不能是相互排斥的。需要能够同事对多个channel进行强化，而不能是简单的针对一个channel的单独强化</li></ol></li></ul></li></ul><h1 id="2-SEBlock-使用"><a href="#2-SEBlock-使用" class="headerlink" title="2. SEBlock 使用"></a>2. SEBlock 使用</h1><p><img src="https://s2.loli.net/2022/05/26/7fjD5Y9QhMwHGsB.png" alt="SEBlock使用"><br>SE block的可伸缩性意味着它可以直接的应用到各类映射上。<br>如上图，是两种典型的SE block的使用场景。在Inception网络中，可以直接对整个Inception模块应用SE Block。对于ResNet，可以将SE Block嵌入到每个残差结构的残差分支当中。</p><h1 id="3-SEBlock在ctr任务中的使用"><a href="#3-SEBlock在ctr任务中的使用" class="headerlink" title="3. SEBlock在ctr任务中的使用"></a>3. SEBlock在ctr任务中的使用</h1><p>SE Block的原始作用是为了解决图片中不同channel的权重强化问题，同样，我们可以将这个逻辑应用到ctr任务中，用来出来对不同的特征域的强弱关注度的学习使用中。<br><img src="https://s2.loli.net/2022/05/26/WrLVdEncBS49JqI.png" alt="seblock-for-ctr"><br>使用逻辑：</p><ol><li>针对每个输入features生成input_embedding（经过preprocessing之后的embedding信息）</li><li>针对之前的输入进行SEBlock的处理，这里可以将原文中的channel概念替换为特征域进行Global pooling的处理</li><li>通过SEBlock之后，会生成一个和特征域个数相同维度weighted向量</li><li>将weighted向量分别加权到对应的特征域之后，将结果作为input信息输入到NN中。</li></ol><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SeBlockLayer</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Layer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    the SeBlock layer for features    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> out_dim<span class="token punctuation">,</span> ratio<span class="token operator">=</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>SeBlockLayer<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>out_dim <span class="token operator">=</span> out_dim        self<span class="token punctuation">.</span>mid_dim <span class="token operator">=</span> tf<span class="token punctuation">.</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>out_dim <span class="token operator">/</span> ratio<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>ratio <span class="token operator">=</span> ratio        self<span class="token punctuation">.</span>avg_weights <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_shape<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>SeBlockLayer<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>build<span class="token punctuation">(</span>input_shape<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> feature_embs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对每个特征域进行global pooling</span>        <span class="token keyword">for</span> feature_emb <span class="token keyword">in</span> feature_embs<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>avg_weights<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>feature_emb<span class="token punctuation">)</span><span class="token punctuation">)</span>        se_inputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>convert_to_tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>avg_weights<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># FC层</span>        outputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>self<span class="token punctuation">.</span>mid_dim<span class="token punctuation">)</span><span class="token punctuation">(</span>se_inputs<span class="token punctuation">)</span>        <span class="token comment"># relu激活</span>        outputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>outputs<span class="token punctuation">)</span>        <span class="token comment"># FC层</span>        outputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>self<span class="token punctuation">.</span>out_dim<span class="token punctuation">)</span><span class="token punctuation">(</span>outputs<span class="token punctuation">)</span>        <span class="token comment"># sigmoid激活</span>        outputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>outputs<span class="token punctuation">)</span>        <span class="token comment"># scaled</span>        se_outputs <span class="token operator">=</span> feature_embs <span class="token operator">*</span> outputs        <span class="token keyword">return</span> se_outputs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>thesis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine-learning</tag>
      
      <tag>Squeeze-and-Excitation</tag>
      
      <tag>attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git同步异常问题</title>
    <link href="/2022/05/21/git/git%E5%90%8C%E6%AD%A5%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/21/git/git%E5%90%8C%E6%AD%A5%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>常见的git同步问题的收集</p></blockquote><span id="more"></span><h1 id="1-LibreSSL-SSL-read"><a href="#1-LibreSSL-SSL-read" class="headerlink" title="1. LibreSSL SSL_read"></a>1. LibreSSL SSL_read</h1><p>在向github推送commit的时候，会包如下错误：<br><img src="https://s2.loli.net/2022/05/21/nESf8NwvXkDbeGt.png" alt="报错信息"><br>上面的错误，可以通过如下的命令解决：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> http.proxy<span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--unset</span> https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>经过处理后，即可以进行再次同步：<br><img src="https://s2.loli.net/2022/05/21/kUyrnTzZLvpBb6g.png" alt="同步成功"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo自定义主页</title>
    <link href="/2022/05/16/blog/hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A1%B5/"/>
    <url>/2022/05/16/blog/hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<p>经过了<a href="https://zermzhang.github.io/2022/04/19/blog/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">上文</a>的介绍之后，我们可以简单的将自己的blog搭建起来。<br>这个时候，blog的主页根据你选择的主题会有一定的不同，但是大多是以文章列表作为主页，如下图：</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/20220517084558.png" alt="原始主页"><br>但是，像我们这种喜欢折腾的人，怎么能接受一直使用默认的页面作为主页呢？那么这时候，自定义主页的需求就开始提上日程了。<br>这里主要介绍一种简单的自定义hexo主页的方法，这种方法其实是通过将一个文章内容作为首页展示的这种方案。</p><h1 id="1-主页内容"><a href="#1-主页内容" class="headerlink" title="1. 主页内容"></a>1. 主页内容</h1><p>想要是用自定义主页，当然需要先创建一个自定的主页内容文件，该文件需要位于<code>/source/</code>文件夹下，文件名需要是<code>index.md</code>，这样才能保证hexo能够读取到这个文件。<br>文件内容可以自定义，如果希望主页内容能够有足够的个性化的话，可以在md文件中通过html、css实现更复杂的功能展示。示例如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token comment">&lt;!--&lt;span style="font-size: 40px;">欢迎&lt;/span>--></span><span class="token blockquote punctuation">></span> 这里是我在日常生活中进行记录的地方，包括又不限于工作、生活、知识、娱乐等方方面面。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://s2.loli.net/2022/05/14/kJga8xRWGnB4Ueo.png<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span> <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span>221<span class="token punctuation">,</span> 222<span class="token punctuation">,</span> 222<span class="token punctuation">)</span> 0px 0px 0px 5px<span class="token punctuation">,</span> white 0px 0px 30px<span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span> 20%<span class="token punctuation">;</span> <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span> <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>这里是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 35px<span class="token punctuation">;</span> <span class="token property">color</span><span class="token punctuation">:</span> #E76D34<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>zermzhang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>的个人博客。 一个毕业于普通学校的普通人。<span class="token title important"><span class="token punctuation">##</span> 我是：</span><span class="token list punctuation">*</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 35px<span class="token punctuation">;</span> <span class="token property">color</span><span class="token punctuation">:</span> #3370AC<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>小说迷<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>，各种小说都喜欢。<span class="token list punctuation">*</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 35px<span class="token punctuation">;</span> <span class="token property">color</span><span class="token punctuation">:</span> #F9D171<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>码农<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>，日常写代码。<span class="token list punctuation">*</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 35px<span class="token punctuation">;</span> <span class="token property">color</span><span class="token punctuation">:</span> #AD2625<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>普通人<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>，自我感觉没有出众的地方。请开始<span class="token url">[<span class="token content">&lt;span style="font-size: 35px; color: rgb(44, 218, 376);">阅读&lt;/span></span>](<span class="token url">/articles/</span>)</span>我的blog吧。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="2-config-yml调整"><a href="#2-config-yml调整" class="headerlink" title="2. _config.yml调整"></a>2. _config.yml调整</h1><p>为了保证能够正常展示自定义主页，并且能够将主页和需要展示的文章列表页进行恰当的链接，需要对_config.yml文件进行调整。<br>主要调整内容如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">index_generator</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">'/articles/'</span>  <span class="token key atrule">per_page</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>index_generator</code>下的<code>path</code>需要调整为一个新的空文件夹的名字，该文件夹下没有内容，这样的话，hexo才能够将原来的主页渲染到这个路径下。<br>自定义主页需要调整的超链接也需要填入当前路径，当然可以是相对路径，从<code>/source/</code>下算起即可。</p><h1 id="3-调整结果"><a href="#3-调整结果" class="headerlink" title="3. 调整结果"></a>3. 调整结果</h1><p>经过了上述调整后，你的自定义主页就可以生效了，尽情的享受与众不同的快乐吧！<br><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/20220517085426.png" alt="自定义主页"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>blog</tag>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh登陆信息配置</title>
    <link href="/2022/05/10/linux/ssh%E7%99%BB%E9%99%86%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/05/10/linux/ssh%E7%99%BB%E9%99%86%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>当你需要经常登陆到远程服务器上进行操作的时候，SSH链接是一个跳不过去的话题。</p><span id="more"></span><p>当你需要链接的服务器相对较少的时候，你可以直接记忆下对应的ip和相关信息，但是随着你需要关注的服务器越来越多，你会发现ip、用户名、密码等信息的记忆对你来说越来越不可承受。<br>当然，OpenSSH早就注意到了这个问题，它允许用户设置配置文件，并通过配置文件里的相关信息进行登陆。</p><h1 id="1-文件说明"><a href="#1-文件说明" class="headerlink" title="1. 文件说明"></a>1. 文件说明</h1><p>配置文件的路径通常位于<code>~/.ssh/config</code>。当然，默认情况下，<code>config</code>文件可能不存在，这个时候你可以手动创建对应的文件，并不会影响后续的使用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">touch ~&#x2F;.ssh&#x2F;config &amp;&amp; chmod 700 ~&#x2F;.ssh&#x2F;config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="2-配置格式"><a href="#2-配置格式" class="headerlink" title="2. 配置格式"></a>2. 配置格式</h1><p>SSH配置文件通常采用如下的配置格式:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Host name1    Port 22    User user-name    HostName ip    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>SSH配置文件中的每一个部分称做一个节。<br>每个节都是以<code>Host</code>开头，并且需要包含每个SSH链接所必需的相关选项。<br>如上面的配置信息，是一个常见的例子：</p><ul><li>Host name1: 当前Host配置的别名，需要的时候可以直接通过当前的别名进行ssh登陆。</li><li>Port 22: ssh建立链接的时候使用的端口，默认是22</li><li>User user-name: 建立ssh链接的时候需要用到的用户名</li><li>HostName ip: ssh链接的目的服务器的ip</li><li>IdentityFile ~&#x2F;.ssh&#x2F;id_rsa: 需要通过私钥登陆的时候的文件</li></ul><p>当你需要使用<code>name1</code>的链接的时候，只需要在命令行中输入<code>ssh name1</code>即可以创建对应的ssh链接。</p><h2 id="2-1-Host模式"><a href="#2-1-Host模式" class="headerlink" title="2.1 Host模式"></a>2.1 Host模式</h2><p>Host指令可以包含一个模型或者是通过空格进行分隔的模式列表。每个模式可以包含零个活多个非空字符或者说明符之一：</p><ol><li><code>*</code> - 匹配任意（零个或多个）个字符<br><code>Host *</code>可以匹配所有的Host</li><li><code>?</code> - 匹配一个字符<br><code>Host mu?</code>可以匹配以<code>mu</code>开头的任意3个字符的Host</li><li><code>!</code> - 否定匹配<br><code>Host * !mu</code>可以匹配除了<code>mu</code>以外的任意Host</li></ol><p>SSH按节对配置文件进行读取，如果有多个host-name匹配，则优先使用第一个匹配到的节中的选项。</p><h2 id="2-2-SSH配置共享"><a href="#2-2-SSH配置共享" class="headerlink" title="2.2 SSH配置共享"></a>2.2 SSH配置共享</h2><p>为了减少SSH配置文件中大量的冗余配置，可以对SSH配置中的内容进行共享，如下例子：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Host zermzhang    User zermzhangHost market    User marketHost *zhang    User zhang    HostName 1.1.1.2    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_2    Host *    User root    HostName 1.1.1.1    Port 22    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如上，这是一个可以互相共享ssh配置信息的SSH配置文件的声明。</p><p>如果在命令行输入<code>ssh zermzhang</code>, 在逐节检测SSH配置文件的过程中，会按照顺序依次匹配到<code>Host zermzhang, Host *zhang, Host *</code>. 匹配到对应的Host之后，会按照匹配到的顺序依次获取对应的ssh配置。</p><ol><li>在<code>Host zermzhang</code>中获取到<code>User</code></li><li>在<code>Host *zhang</code>中获取到<code>User, HostName, IdentityFile</code>三个配置。但是因为已经在<code>Host zermzhang</code>中获取到了<code>User</code>，所以在该节中只会采用<code>HostName, IdentityFile</code>两个配置。</li><li>同样，在<code>Host *</code>中只会采用<code>Port</code>这一个配置。</li></ol><p>因此，输入<code>ssh zermzhang</code>之后可以获取到的完整配置是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">User zermzhangHostName 1.1.1.2IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_2Port 22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>后续，OpenSSH客户端会根据上述信息创建对应的ssh链接</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过expect进行自动ssh登陆</title>
    <link href="/2022/05/10/linux/%E9%80%9A%E8%BF%87expect%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8ssh%E7%99%BB%E9%99%86/"/>
    <url>/2022/05/10/linux/%E9%80%9A%E8%BF%87expect%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8ssh%E7%99%BB%E9%99%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是为了解决通过跳板机&#x2F;堡垒机登陆时，在完成ssh链接之后依旧有一些操作需要处理的问题。<br>如何配置通过SSH配置文件创建SSH链接，可以参考<a href="https://zermzhang.github.io/2022/05/10/linux/ssh%E7%99%BB%E9%99%86%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE/">本文</a></p></blockquote><span id="more"></span><h1 id="1-堡垒机"><a href="#1-堡垒机" class="headerlink" title="1. 堡垒机"></a>1. 堡垒机</h1><p>堡垒机，即在一个特定的网络环境下，为了保证网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段监控、记录运维远远对网络内部的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理和审计定责。<br>上面这一段官话时百度百科对堡垒机的定义。<br>但是我们这种非运维人员对堡垒机的印象可能就是简单的在服务器之间加了一层，增加了登陆服务器的成本而已。当然，我们这里不讨论堡垒机的具体作用，只是为了解决如何在terminal下通过expect脚本自动跳过堡垒机上的相关操作。<br><img src="https://s2.loli.net/2022/05/10/eH1ZdGV4UbPf5Lv.png" alt="堡垒机例子"><br>如上图，是常见的堡垒机登陆的页面，expect脚本主要是为了跳过每次登陆过程中的选择过程。</p><h1 id="2-expect脚本"><a href="#2-expect脚本" class="headerlink" title="2. expect脚本"></a>2. expect脚本</h1><p>expect是一个自动化交互的工具，主要是在执行命令时，可以通过交互的方式根据返回输入指定的字符串。<br>整体流程主要由4个部分组成：</p><ol><li>spawn：启动指定的进程</li><li>expect：检测是否获取到指定的关键字</li><li>send：向进程发送指定字符</li><li>执行完成退出</li></ol><h2 id="2-1-常用命令总结"><a href="#2-1-常用命令总结" class="headerlink" title="2.1 常用命令总结"></a>2.1 常用命令总结</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>spawn</td><td>交互程序开始，后面跟指定进程的命令</td></tr><tr><td>expect</td><td>获取匹配信息，成功话，执行后续命令</td></tr><tr><td>send</td><td>发送指定字符串信息</td></tr><tr><td>exp_continue</td><td>在expect中需要多次匹配的时候，表示中间过程</td></tr><tr><td>send_user</td><td>打印输出，相当于echo</td></tr><tr><td>exit</td><td>退出expect脚本</td></tr><tr><td>eof</td><td>expect执行结束</td></tr><tr><td>interact</td><td>执行完成后保持交互状态，可以手动操作。如果没有这一句执行结束后会直接退出</td></tr><tr><td>set</td><td>定义变量</td></tr><tr><td>puts</td><td>输出变量</td></tr><tr><td>set timeout</td><td>设置超时时间</td></tr></tbody></table><h2 id="2-2-脚本例子"><a href="#2-2-脚本例子" class="headerlink" title="2.2 脚本例子"></a>2.2 脚本例子</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/expect</span>spawn <span class="token function">ssh</span> work-ali<span class="token function">expect</span> <span class="token punctuation">&#123;</span>    <span class="token string">"请选择目标资产："</span> <span class="token punctuation">&#123;</span>send <span class="token string">"<span class="token variable">$&#123;需要登陆的机器编号&#125;</span><span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span> exp_continue<span class="token punctuation">&#125;</span>    <span class="token string">"*\$ "</span> <span class="token punctuation">&#123;</span>send <span class="token string">"<span class="token variable">$&#123;登陆到指定机器后需要执行的命令&#125;</span><span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>interact<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ssh</tag>
      
      <tag>expect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tf中ProfilerHoo的使用</title>
    <link href="/2022/05/03/tensorflow/tf%E4%B8%ADProfilerHook%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/03/tensorflow/tf%E4%B8%ADProfilerHook%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ProfilerHook"><a href="#1-ProfilerHook" class="headerlink" title="1. ProfilerHook"></a>1. ProfilerHook</h1><p>在深度学习训练过程中，经常会遇到性能的问题，为了提高训练过程的效率，各个训练环节的耗时分析和性能优化是必须的。<br>而如果通过手动打印日志和耗时情况，不仅繁琐，而且准确度不高。那么我们可以通过tf提供的Profiler工具进行相关分析。</p><span id="more"></span><p>tf里的<code>tf.estimator.ProfilerHook</code>就是一个可以定期收集分析信息的接口，通过该接口收集到的信息会被保存到”timeline-${step}.json”文件中，这些文件可以直接通过<code>chrome://tracing/</code>导入可视化，方便具体分析每个流程的耗时情况。</p><h1 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train_and_eval</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param model: 声明的estimator实例    :return: None    :usage: 进行模型训练，并在指定步长的时候进行结果评估    """</span>    timeline_hook <span class="token operator">=</span> tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span>ProfilerHook<span class="token punctuation">(</span>save_steps<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> output_dir<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>            os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'./timeline_track'</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span>    hook <span class="token operator">=</span> tf<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>stop_if_no_increase_hook<span class="token punctuation">(</span>        model<span class="token punctuation">,</span>        metric_name<span class="token operator">=</span><span class="token string">'ctcvr_cvr_auc_esmm'</span><span class="token punctuation">,</span>        max_steps_without_increase<span class="token operator">=</span>configuration_params<span class="token punctuation">[</span><span class="token string">'max_steps_without_increase'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token comment"># maximum number of training steps with no decrease in the given metric.</span>        min_steps<span class="token operator">=</span>configuration_params<span class="token punctuation">[</span><span class="token string">'min_steps'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># stop is never requested if global step is less than this value</span>        run_every_steps<span class="token operator">=</span>configuration_params<span class="token punctuation">[</span><span class="token string">'run_every_steps'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        run_every_secs<span class="token operator">=</span><span class="token boolean">None</span>    <span class="token punctuation">)</span>    train_spec <span class="token operator">=</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>TrainSpec<span class="token punctuation">(</span>        input_fn<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> input_fn<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                               CONFIG_TRAIN<span class="token punctuation">[</span><span class="token string">'train_data'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                  <span class="token string">'train'</span><span class="token punctuation">,</span> CONFIG_TRAIN<span class="token punctuation">[</span><span class="token string">'batch_size'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        hooks<span class="token operator">=</span><span class="token punctuation">[</span>hook<span class="token punctuation">,</span> timeline_hook<span class="token punctuation">]</span>    <span class="token punctuation">)</span>    eval_spec <span class="token operator">=</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>EvalSpec<span class="token punctuation">(</span>        input_fn<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> input_fn<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                               CONFIG_TRAIN<span class="token punctuation">[</span><span class="token string">'test_data'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                  <span class="token string">'eval'</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        steps<span class="token operator">=</span>CONFIG<span class="token punctuation">.</span>evalconfig<span class="token punctuation">[</span><span class="token string">'steps'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        throttle_secs<span class="token operator">=</span><span class="token number">30</span>        <span class="token punctuation">)</span>    tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>train_and_evaluate<span class="token punctuation">(</span>model<span class="token punctuation">,</span> train_spec<span class="token punctuation">,</span> eval_spec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="2-1-参数说明"><a href="#2-1-参数说明" class="headerlink" title="2.1 参数说明"></a>2.1 参数说明</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>save_steps</td><td>间隔多少步保存一次profiler trace</td></tr><tr><td>save_secs</td><td>间隔多少秒保存一次profiler trace，save_steps和save_secs只设置一个</td></tr><tr><td>output_dir</td><td>profiler trace文件的存储路径</td></tr></tbody></table><h2 id="2-2-输出信息"><a href="#2-2-输出信息" class="headerlink" title="2.2 输出信息"></a>2.2 输出信息</h2><p><img src="https://s2.loli.net/2022/05/03/7YpS2AOl5qHuECo.png" alt="profiler-output"></p><ul><li>timeline-${step}.json：每个报错步长输出的profiler trace文件</li></ul><h1 id="3-web分析"><a href="#3-web分析" class="headerlink" title="3. web分析"></a>3. web分析</h1><ol><li>在浏览器中打开<code>chrome://tracing/</code>页面<br><img src="https://s2.loli.net/2022/05/03/t1NwGXKhT7FsgZl.png" alt="tracing-page"></li><li>通过<code>load</code>将profiler trace文件导入浏览器</li><li>分析具体耗时情况<br><img src="https://s2.loli.net/2022/05/03/w9rgJIdiGEABQX3.png" alt="time-cost"></li></ol>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>profilerhook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对dataframe使用自定义函数</title>
    <link href="/2022/05/02/python/%E5%AF%B9dataframe%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/02/python/%E5%AF%B9dataframe%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>在日常的数据处理过程中，分类聚合操作是一种常见的操作类型，而在pandas中，这种操作常通过<code>groupby</code>完成。<br>但是在groupby过程中，经常会有一些需要进行额外的自定义操作需要进行处理。<br>本文主要是为了介绍groupby过程中如何使用自定义操作对groupby之后的数据集进行对应的操作处理。</p><span id="more"></span><h1 id="2-处理过程"><a href="#2-处理过程" class="headerlink" title="2. 处理过程"></a>2. 处理过程</h1><p>dataframe在进行了groupby之后，可以通过自定义的操作函数，对sub_df进行指定处理。</p><p>操作过程如下图：<br><img src="https://s2.loli.net/2022/05/02/8KkMsmiAPcvRU1V.png" alt="apply"><br><img src="https://s2.loli.net/2022/05/02/jc9dPvb5zLY6oNU.png" alt="progress"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>dataframe</tag>
      
      <tag>apply</tag>
      
      <tag>custom function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github-pic-service</title>
    <link href="/2022/04/30/git/github%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/04/30/git/github%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>在日常写blog的过程中，我习惯使用markdown编写文章内容，这时候需要提供图片的地址以方便文章中可以显示图片，将图片放到本地当然方便，但是这样随着blog文章的增加，需要处理的源文件也越来越大。<br>而且这种情况下，文章内容不方便进行不同平台的迁移，迁移到其他平台的时候，为了防止文章中的图片无法显示，只能同时调整图片位置。</p><span id="more"></span><p>为了解决上面的两个痛点，决定增加一个图床服务，方便在不同位置上都可以正常的访问文章中的图片情况而不受影响。</p><h1 id="1-常用的图床服务"><a href="#1-常用的图床服务" class="headerlink" title="1. 常用的图床服务"></a>1. 常用的图床服务</h1><ol><li>github图床</li><li>SM.MS图床</li><li>七牛云图床</li><li>腾讯云</li><li>阿里云</li></ol><p>上面是一些常用的图床服务，各有千秋，我现在使用的图床服务是github的图床，github最大的优点就是所有数据都是存储在你的github仓库上，完全可控，但是国内github的访问情况就会导致在没有工具或者是网络不好的情况下，图片打开很慢或者完全打不开。<br>如果大家希望能有一个比较稳定的国内访问环境的话，可以考虑其他的图床，或者通过cdn进行加速访问。</p><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h1><h2 id="2-1-准备一个github仓库"><a href="#2-1-准备一个github仓库" class="headerlink" title="2.1 准备一个github仓库"></a>2.1 准备一个github仓库</h2><p>这一步比较简单，生成一个新的仓库，用来存储需要用到的图片，除了仓库权限需要是public的之外，其他的并没有什么要求，全部默认即可。<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20220430082824.png" alt="register-repository"></p><h2 id="2-2-上传图片"><a href="#2-2-上传图片" class="headerlink" title="2.2 上传图片"></a>2.2 上传图片</h2><blockquote><p>图片上传方式可以使用传统的git同步逻辑，但是相对比较繁琐，所有推荐使用工具进行图片上传，常用的工具是PicGO</p></blockquote><p><strong>通过PicGO上传图片</strong></p><ol><li><p>下载安装PicGo<br>先从<a href="https://molunerfinn.com/PicGo/">官网</a>下载，然后安装。</p></li><li><p>配置PicGo<br>配置PicGo的过程主要是指定github中需要使用到的仓库名，分支名和同步过程中需要使用到的token。<br>存储路径和自定义域名可以直接使用默认的值。<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20220430083319.png" alt="config-for-PicGo"></p></li></ol><h1 id="3-图床使用"><a href="#3-图床使用" class="headerlink" title="3. 图床使用"></a>3. 图床使用</h1><h2 id="3-1-上传图片"><a href="#3-1-上传图片" class="headerlink" title="3.1 上传图片"></a>3.1 上传图片</h2><p>PicGo支持方便的图片上传功能，可以直接通过拖拽将指定图片拖到上传区域中，即可上传。<br>截图的图片可以通过打开软件的方式，直接上传，很是便捷。<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20220430083616.png" alt="upload-pic"></p><h2 id="3-2-获取图片链接"><a href="#3-2-获取图片链接" class="headerlink" title="3.2 获取图片链接"></a>3.2 获取图片链接</h2><p>图片上传结束之后，就可以直接在相册中找到这张图片，通过点击的方式就可以将图片的链接复制到剪切板中。<br>之后，直接将图片的url粘贴到md格式的文章中就可以直接在文章里显示了。<br><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/20220430083651.png" alt="copy-pic-url"></p><h1 id="4-存在的问题"><a href="#4-存在的问题" class="headerlink" title="4. 存在的问题"></a>4. 存在的问题</h1><ol><li>网络问题<br>因为这里的图床是通过github实现的，网络需要经过github，所有在网络不好的情况下，经常会出现网页图片无法显示的问题，需要的话可以切换到国内的图床工具上。</li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>github</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tf2中构建模型的三种方法</title>
    <link href="/2022/04/29/tensorflow/tf2%E4%B8%AD%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2022/04/29/tensorflow/tf2%E4%B8%AD%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>tf2版本中，提供了三种不同的模型构建逻辑。</p><span id="more"></span><ol><li>sequential API<br>适用于层叠式的模型层结构，并且每层都只有一个明确的输入tensor和输出tensor</li><li>functional API<br>函数式ＡＰＩ是一种比Sequential API跟加简单和灵活的模型创建方式。<br>函数式API可以处理具有非线性拓扑的模型、具有共享层的模型，以及具有多个输入或输出的模型</li><li>model subclassing API<br>model subclassing API具有更大的自由度，可以让开发者控制模型、layer以及训练过程</li></ol><p><img src="https://raw.githubusercontent.com/ZermZhang/pictures/main/diff-api.jpeg" alt="diff-api"></p><h1 id="1-Sequential-API"><a href="#1-Sequential-API" class="headerlink" title="1. Sequential API"></a>1. Sequential API</h1><h2 id="1-1-构建方法"><a href="#1-1-构建方法" class="headerlink" title="1.1 构建方法"></a>1.1 构建方法</h2><p>构建Sequential 模型主要通过Sequential constructor对layers的列表进行模型构建</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">model <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">"relu"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">"relu"</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/show.5w4zduij7tw0.webp" alt="show"></p><h2 id="1-2-其他构建方法"><a href="#1-2-其他构建方法" class="headerlink" title="1.2 其他构建方法"></a>1.2 其他构建方法</h2><ul><li>除了直接通过sequential constructor对layers list进行模型构建外，也可以通过sequential constructor的add属性逐层进行构建</li><li>注意，通过这种方法进行模型构建的时候可以将一个 ​name​ 传入到sequential constructor中<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 声明模型</span>model <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'my_test_model'</span><span class="token punctuation">)</span><span class="token comment"># 声明模型的各层结构</span>model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul><h1 id="2-Functional-API"><a href="#2-Functional-API" class="headerlink" title="2. Functional API"></a>2. Functional API</h1><h2 id="2-1-构建方法"><a href="#2-1-构建方法" class="headerlink" title="2.1 构建方法"></a>2.1 构建方法</h2><ul><li>注意：通过Functional API进行模型构建的时候，需要先创建一个输入节点：<code>inputs = tf.keras.Input(shape=(512, 128))</code></li><li>然后可以在<code>inputs</code>对象上调用层，在层计算图中创建新的节点, <code>tf.keras.layers.Dense(64, activation=&#39;relu&#39;)(inputs)</code></li><li>每调用一个层，就意味着将上一个层的输出作为新的调用层的输入，并通过该层处理后进行输出结果。</li><li>最后，可以通过<code>tf.keras.Model</code>指定输入和输出来创建模型。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建输入层</span>inputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 中间层可以调用多个layers</span>x <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token comment"># 创建输出层</span>outputs <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment"># 声明模型</span>model <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">(</span>inputs<span class="token operator">=</span>inputs<span class="token punctuation">,</span> outputs<span class="token operator">=</span>outputs<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'my_test_model'</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>plot_model<span class="token punctuation">(</span>model<span class="token punctuation">,</span> show_shapes<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="2-2-使用模型进行训练、评估和推断"><a href="#2-2-使用模型进行训练、评估和推断" class="headerlink" title="2.2 使用模型进行训练、评估和推断"></a>2.2 使用模型进行训练、评估和推断</h2><p>通过Functional API和Sequential API构建的模型，都可以通过同一种方法进行模型的训练、评估和推断工作。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 通过tf.data.datasets创建data_generator</span>batch_data <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>datasets<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment"># 模型编译, 模型编译过程中需要声明模型训练过程中需要用到的loss_func, optimizer_func和评估需要用到的metric_func</span><span class="token comment"># 用到的这三种func都可以是按照规范自定义的或者式已经存在的</span>loss_func <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>losses<span class="token punctuation">.</span>SparseCategoricalCrossentropy<span class="token punctuation">(</span>from_logits<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>optimizer_func <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>optimizers<span class="token punctuation">.</span>RMSprop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 直接通过tf.keras.metrics中API的name进行调用，类似'accuracy', 'AUC'等</span>metrics_name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token comment"># 模型编译</span>model<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>loss<span class="token operator">=</span>loss_func<span class="token punctuation">,</span> optimizer<span class="token operator">=</span>optimizer_func<span class="token punctuation">,</span> metrics<span class="token operator">=</span>metrics_name<span class="token punctuation">)</span><span class="token comment"># 使用已经编译好的模型进行训练</span><span class="token comment"># model.fit(x_train, y_train)</span><span class="token comment"># model.fit 可以作用在分离的features和labels上，也可以直接作用在data_generator上</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>batch_data<span class="token punctuation">)</span><span class="token comment"># 模型评估</span>test_score <span class="token operator">=</span> model<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span>batch_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="3-Subclassing-API"><a href="#3-Subclassing-API" class="headerlink" title="3. Subclassing API"></a>3. Subclassing API</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TestModel</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>TestModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        emb <span class="token operator">=</span> self<span class="token punctuation">.</span>dense1<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>        emb <span class="token operator">=</span> self<span class="token punctuation">.</span>dense2<span class="token punctuation">(</span>emb<span class="token punctuation">)</span>        <span class="token keyword">return</span> emb        <span class="token keyword">def</span> <span class="token function">build_graph</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_shape<span class="token punctuation">)</span><span class="token punctuation">:</span>        input_ <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span>input_shape<span class="token punctuation">)</span>        <span class="token keyword">return</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">(</span>inputs<span class="token operator">=</span><span class="token punctuation">[</span>input_<span class="token punctuation">]</span><span class="token punctuation">,</span> outputs<span class="token operator">=</span>self<span class="token punctuation">.</span>call<span class="token punctuation">(</span>input_<span class="token punctuation">)</span><span class="token punctuation">)</span>model <span class="token operator">=</span> TestModel<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>build_graph<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>plot_model<span class="token punctuation">(</span>model<span class="token punctuation">.</span>build_graph<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> show_shapes<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>subclassing种的build_graph不是必须的，但是不具有build_graph的subclass无法进行模型结构的展示。<br>可以通过如下<a href="https://zermzhang.github.io/2022/04/25/tf2%E4%B8%ADsubclassing%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B/">方式</a>，进行模型结构的展示。</p>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>subclassing</tag>
      
      <tag>sequenctial</tag>
      
      <tag>functional</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tf2里导入pretrain-embedding的方法</title>
    <link href="/2022/04/29/tensorflow/tf2%E9%87%8C%E5%AF%BC%E5%85%A5pretrain-embedding%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/04/29/tensorflow/tf2%E9%87%8C%E5%AF%BC%E5%85%A5pretrain-embedding%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在深度模型训练中，我们经常会使用到pre-train embedding，比如glove、w2v等模型的输出，尤其是在nlp和推广搜业务中。<br>面对多种多样的embdding形式，如何方便的利用就成为了一个问题，这里记录一下我用来reload embedding的方法。</p></blockquote><span id="more"></span><h1 id="1-embedding存储方式"><a href="#1-embedding存储方式" class="headerlink" title="1. embedding存储方式"></a>1. embedding存储方式</h1><h2 id="1-1-单层映射"><a href="#1-1-单层映射" class="headerlink" title="1.1 单层映射"></a>1.1 单层映射</h2><p>pre-train embedding的存储方式多种多样，最常见的一种是直接存到在文件中，通过&lt;key, vlaue&gt;的方式进行存储。</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># file_nameid1\t0.1,0.2,0.3,0.4,0.5id2\t0.3,0.4,0.5,0.3,0.5id3\t0.2,0.4,0.2,0.3,0.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>该方式可以将key, value分别存储成个一个list，方便后续查找。</p><h2 id="1-2-多层映射"><a href="#1-2-多层映射" class="headerlink" title="1.2 多层映射"></a>1.2 多层映射</h2><p>还有多层映射的embedding存储，为了节省存储空间，可能会通过多个文件进行存储</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text"># file_name_1id1\tattr1,attr2id2\tattr2,attr3# file_name_2attr1\t0.1,0.2,0.3,0.4,0.5attr2\t0.3,0.4,0.5,0.3,0.5attr3\t0.2,0.4,0.2,0.3,0.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这种情况下，需要存储多个list，分别是id的list，id对应的属性的list，属性对应的embedding的list。</p><p>如上两种embedding的存储方式，都可以通过tf2中已有方法进行快速的embeding查找。</p><h1 id="2-处理逻辑"><a href="#2-处理逻辑" class="headerlink" title="2. 处理逻辑"></a>2. 处理逻辑</h1><blockquote><p>主要处理逻辑分成两部分：</p><ol><li>获取需要的embedding在embedding list中的idx</li><li>根据idx获取需要的embdding</li></ol></blockquote><h2 id="2-1-获取idx"><a href="#2-1-获取idx" class="headerlink" title="2.1 获取idx"></a>2.1 获取idx</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">InputIdxLayer</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>preprocessing<span class="token punctuation">.</span>PreprocessingLayer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    获取输入特征对应的特征list中的idx信息，方便后续从embeddinglist中获取需要的embdding    1. 直接映射        item => idx for item in inputs_list    2. 间接映射        item => attr => idx for item's attr in target_list    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs_list<span class="token punctuation">:</span> List<span class="token punctuation">,</span> mapping_list<span class="token punctuation">:</span> List <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>                 target_list<span class="token punctuation">:</span> List <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>InputIdxLayer<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>inputs_list <span class="token operator">=</span> inputs_list        self<span class="token punctuation">.</span>mapping_list <span class="token operator">=</span> mapping_list        self<span class="token punctuation">.</span>target_list <span class="token operator">=</span> target_list        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>inputs_list<span class="token punctuation">,</span> self<span class="token punctuation">.</span>mapping_list<span class="token punctuation">,</span> self<span class="token punctuation">.</span>target_list<span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>mapping_list <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>target_table <span class="token operator">=</span> self<span class="token punctuation">.</span>get_table<span class="token punctuation">(</span>self<span class="token punctuation">.</span>inputs_list<span class="token punctuation">,</span>                                               <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>inputs_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>mapping_table <span class="token operator">=</span> self<span class="token punctuation">.</span>get_table<span class="token punctuation">(</span>self<span class="token punctuation">.</span>inputs_list<span class="token punctuation">,</span> self<span class="token punctuation">.</span>mapping_list<span class="token punctuation">,</span>                                                default_value<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>target_table <span class="token operator">=</span> self<span class="token punctuation">.</span>get_table<span class="token punctuation">(</span>self<span class="token punctuation">.</span>target_list<span class="token punctuation">,</span>                                               <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>target_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">get_table</span><span class="token punctuation">(</span>keys<span class="token punctuation">:</span> List<span class="token punctuation">,</span> vals<span class="token punctuation">:</span> List<span class="token punctuation">,</span> default_value<span class="token punctuation">:</span> Any <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        init <span class="token operator">=</span> tf<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>KeyValueTensorInitializer<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> vals<span class="token punctuation">)</span>        table <span class="token operator">=</span> tf<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>StaticHashTable<span class="token punctuation">(</span>init<span class="token punctuation">,</span> default_value<span class="token operator">=</span>default_value<span class="token punctuation">)</span>        <span class="token keyword">return</span> table    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>mapping_table <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            idx_ <span class="token operator">=</span> self<span class="token punctuation">.</span>target_table<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>            <span class="token keyword">return</span> idx_        <span class="token keyword">else</span><span class="token punctuation">:</span>            target_ <span class="token operator">=</span> self<span class="token punctuation">.</span>mapping_table<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>            idx_ <span class="token operator">=</span> self<span class="token punctuation">.</span>target_table<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span>target_<span class="token punctuation">)</span>            <span class="token keyword">return</span> idx_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="2-2-获取embdding"><a href="#2-2-获取embdding" class="headerlink" title="2.2 获取embdding"></a>2.2 获取embdding</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">LoadEmbeddingLayer</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Layer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    get the pre-trained embedding in embdding List    inpust: the idx_ output from InputIdxLayer    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> embedding<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>LoadEmbeddingLayer<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>embedding <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span>embedding<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>embedding_lookup<span class="token punctuation">(</span>self<span class="token punctuation">.</span>embedding<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>custom layers</tag>
      
      <tag>preprocessing</tag>
      
      <tag>pre-train</tag>
      
      <tag>embedding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过preprocessing构建tf2模型</title>
    <link href="/2022/04/26/tensorflow/%E9%80%9A%E8%BF%87preprocessing%E6%9E%84%E5%BB%BAtf2%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/26/tensorflow/%E9%80%9A%E8%BF%87preprocessing%E6%9E%84%E5%BB%BAtf2%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><blockquote><p>tf2.x里增加了一类特殊的keras layers, 可以替代<code>tf.feature_column</code>进行特征处理，这一类的layers就是<code>preprocessing layers</code></p></blockquote><span id="more"></span><p>通过preprocessing对特征进行处理，在实现逻辑上，相对feature_column要更统一一些。<br>本文主要是记录一些通过preprocessing进行特征处理的过程，以及从feature_column迁移到preprocessing的过程中需要注意的事项。</p><h1 id="2-preprocessing过程构建"><a href="#2-preprocessing过程构建" class="headerlink" title="2. preprocessing过程构建"></a>2. preprocessing过程构建</h1><blockquote><p>通过调用preprocessing对特征处理的逻辑和feture_column基本类似<br>这里主要涉及到两个过程，一个是直接声明preprocessing-layers，方便对原始数据进行处理<br>另外一个是inputs格式的声明，方便通过summary可视化分析模型和export模型</p></blockquote><ol><li>build_encoded_features<br>该函数会根据原始特征的格式不同进行不同的preprocessing layer的声明，方便后续的特征处理。</li><li>build_inputs<br>该函数负责生成不同特征的指定格式，方便输出可视化模型结构</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">EncodedFeatureBuilder</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">build_encoded_features</span><span class="token punctuation">(</span>feature_config<span class="token punctuation">)</span><span class="token punctuation">:</span>        feature_encoder_type <span class="token operator">=</span> feature_config<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span>        feature_encoder_params <span class="token operator">=</span> feature_config<span class="token punctuation">[</span><span class="token string">'config'</span><span class="token punctuation">]</span>        feature_embedding_params <span class="token operator">=</span> feature_config<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'embed_config'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> feature_encoder_type <span class="token operator">==</span> <span class="token string">'hashing'</span><span class="token punctuation">:</span>            encoding_layer <span class="token operator">=</span> HashEmbeddingBuilder<span class="token punctuation">(</span>                feature_params<span class="token operator">=</span>feature_encoder_params<span class="token punctuation">,</span>                emb_params<span class="token operator">=</span>feature_embedding_params            <span class="token punctuation">)</span>            <span class="token keyword">return</span> encoding_layer        <span class="token keyword">elif</span> feature_encoder_type <span class="token operator">==</span> <span class="token string">'vocabulary'</span><span class="token punctuation">:</span>            encoding_layer <span class="token operator">=</span> VocabEmbeddingBuilder<span class="token punctuation">(</span>                feature_params<span class="token operator">=</span>feature_encoder_params<span class="token punctuation">,</span>                emb_params<span class="token operator">=</span>feature_embedding_params            <span class="token punctuation">)</span>            <span class="token keyword">return</span> encoding_layer        <span class="token keyword">elif</span> feature_encoder_type <span class="token operator">==</span> <span class="token string">'numerical'</span><span class="token punctuation">:</span>            encoding_layer <span class="token operator">=</span> NumericalBuilder<span class="token punctuation">(</span>                feature_params<span class="token operator">=</span>feature_encoder_params<span class="token punctuation">,</span>                emb_params<span class="token operator">=</span>feature_embedding_params            <span class="token punctuation">)</span>            <span class="token keyword">return</span> encoding_layer        <span class="token keyword">elif</span> feature_encoder_type <span class="token operator">==</span> <span class="token string">'pre-trained'</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"There is no preprocessing layer for type: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>feature_encoder_type<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>        <span class="token keyword">elif</span> feature_encoder_type <span class="token operator">==</span> <span class="token string">'crossed'</span><span class="token punctuation">:</span>            encoding_layer <span class="token operator">=</span> CrossedBuilder<span class="token punctuation">(</span>                feature_params<span class="token operator">=</span>feature_encoder_params<span class="token punctuation">,</span>                emb_params<span class="token operator">=</span>feature_embedding_params            <span class="token punctuation">)</span>            <span class="token keyword">return</span> encoding_layer        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"There is no preprocessing layer for type: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>feature_encoder_type<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">build_inputs</span><span class="token punctuation">(</span>feature_name<span class="token punctuation">,</span> feature_config<span class="token punctuation">)</span><span class="token punctuation">:</span>        feature_encoder_type <span class="token operator">=</span> feature_config<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> feature_encoder_type <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'hashing'</span><span class="token punctuation">,</span> <span class="token string">'vocabulary'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            input_col <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token operator">=</span>feature_name<span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>string<span class="token punctuation">)</span>            <span class="token keyword">return</span> input_col        <span class="token keyword">elif</span> feature_encoder_type <span class="token keyword">in</span> <span class="token punctuation">&#123;</span><span class="token string">'numerical'</span><span class="token punctuation">&#125;</span><span class="token punctuation">:</span>            input_col <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token operator">=</span>feature_name<span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>            <span class="token keyword">return</span> input_col        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"There is no preprocessing layer for type: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>feature_encoder_type<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="3-模型结构"><a href="#3-模型结构" class="headerlink" title="3. 模型结构"></a>3. 模型结构</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MLP</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MLP<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># init the feature config info</span>        self<span class="token punctuation">.</span>config <span class="token operator">=</span> config        <span class="token comment"># definite the layers</span>        self<span class="token punctuation">.</span>feature_encoder_layers <span class="token operator">=</span> EncodedFeatureBuilder<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense_layer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dropout_layer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>output_layer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        encoded_features <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> feature_name<span class="token punctuation">,</span> feature_config <span class="token keyword">in</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            encoded_features<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                self<span class="token punctuation">.</span>feature_encoder_layers<span class="token punctuation">.</span>build_encoded_features<span class="token punctuation">(</span>feature_config<span class="token punctuation">)</span><span class="token punctuation">(</span>inputs<span class="token punctuation">[</span>feature_name<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        x <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>encoded_features<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>dense_layer<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout_layer<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>output_layer<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> x    <span class="token keyword">def</span> <span class="token function">build_graph</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        all_inputs <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> feature_name<span class="token punctuation">,</span> feature_config <span class="token keyword">in</span> self<span class="token punctuation">.</span>config<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            all_inputs<span class="token punctuation">[</span>feature_name<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>feature_encoder_layers<span class="token punctuation">.</span>build_inputs<span class="token punctuation">(</span>feature_name<span class="token punctuation">,</span> feature_config<span class="token punctuation">)</span>        <span class="token keyword">return</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">(</span>            inputs<span class="token operator">=</span>all_inputs<span class="token punctuation">,</span>            outputs<span class="token operator">=</span>self<span class="token punctuation">.</span>call<span class="token punctuation">(</span>all_inputs<span class="token punctuation">)</span>        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="4-调用流程"><a href="#4-调用流程" class="headerlink" title="4. 调用流程"></a>4. 调用流程</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">config <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'PhotoAmt'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'numerical'</span><span class="token punctuation">,</span>        <span class="token string">'config'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'bin_boundaries'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">1.</span><span class="token punctuation">,</span> <span class="token number">2.</span> <span class="token punctuation">,</span><span class="token number">3.</span><span class="token punctuation">,</span> <span class="token number">4.</span><span class="token punctuation">,</span> <span class="token number">5.</span><span class="token punctuation">,</span> <span class="token number">6.</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string">'Fee'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'numerical'</span><span class="token punctuation">,</span>        <span class="token string">'config'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'num_bins'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'numerical'</span><span class="token punctuation">,</span>        <span class="token string">'config'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'num_bins'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string">'Type'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'hashing'</span><span class="token punctuation">,</span>        <span class="token string">'config'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'num_bins'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string">'Color1'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'hashing'</span><span class="token punctuation">,</span>        <span class="token string">'config'</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'num_bins'</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>feature_encoder <span class="token operator">=</span> EncodedFeatureBuilder<span class="token punctuation">(</span>config<span class="token punctuation">)</span>model <span class="token operator">=</span> MLP<span class="token punctuation">(</span>feature_encoder<span class="token punctuation">)</span>model<span class="token punctuation">.</span>build_graph<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>plot_model<span class="token punctuation">(</span>model<span class="token punctuation">.</span>build_graph<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> to_file<span class="token operator">=</span><span class="token string">'./test_model.png'</span><span class="token punctuation">,</span> show_shapes<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>subclassing</tag>
      
      <tag>custom model</tag>
      
      <tag>preprocessin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tf2中subclassing自定义模型</title>
    <link href="/2022/04/25/tensorflow/tf2%E4%B8%ADsubclassing%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/25/tensorflow/tf2%E4%B8%ADsubclassing%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-tf2中的subclassing模型"><a href="#1-tf2中的subclassing模型" class="headerlink" title="1. tf2中的subclassing模型"></a>1. tf2中的subclassing模型</h1><p>tf2中常见的定义模型的方法分成三种：functional、sequenctial、subclassing</p><span id="more"></span><p>其中，subclassing方法就是自己实现一个类来继承<code>tf.keras.Model</code>，来构建一个Model类的子类，在构建过程中，主要需要实现下面两个方法：</p><ol><li><code>__init__()</code><br>这个方法是子类的构造器，主要是用来初始化参数（比如layers之类的）。<br><code>super</code>主要用来初始化父构造器。</li><li><code>call()</code><br>该函数用于执行在<code>__init__</code>中定义的layers操作<br>同时，该函数可以使我们定义的模型直接作为函数使用，该功能主要依赖于python的<code>__call__</code>实现。</li></ol><h1 id="2-subclassing模型的例子"><a href="#2-subclassing模型的例子" class="headerlink" title="2. subclassing模型的例子"></a>2. subclassing模型的例子</h1><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">class</span> <span class="token class-name">MLP</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MLP<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>flatten <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>units<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>units<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>dense1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>dense2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        output <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="3-使用summary-plot-model观察模型结构"><a href="#3-使用summary-plot-model观察模型结构" class="headerlink" title="3. 使用summary&#x2F;plot_model观察模型结构"></a>3. 使用summary&#x2F;plot_model观察模型结构</h1><p>上述的模型定义无法通过summary观察模型结构，主要是因为在定义模型的时候没有指定input_shape，只需要增加一个定义input_shape的函数就可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">build_graph</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    input_ <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Input<span class="token punctuation">(</span>shape<span class="token operator">=</span>input_shape<span class="token punctuation">)</span>    <span class="token keyword">return</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">(</span>inputs<span class="token operator">=</span><span class="token punctuation">[</span>input_<span class="token punctuation">]</span><span class="token punctuation">,</span> outputs<span class="token operator">=</span>self<span class="token punctuation">.</span>call<span class="token punctuation">(</span>input_<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>增加该函数后，即可以在定义input_shape之后通过summary和plot_model直观的观察模型结构情况。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义模型</span>test_model <span class="token operator">=</span> MLP<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="3-1-summary输出"><a href="#3-1-summary输出" class="headerlink" title="3.1 summary输出"></a>3.1 summary输出</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 通过summary观察模型结构</span>test_model<span class="token punctuation">.</span>build_graph<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/summary-output.73utxot6e5s0.webp" alt="summary-output"></p><h2 id="3-2-plot-model输出"><a href="#3-2-plot-model输出" class="headerlink" title="3.2 plot_model输出"></a>3.2 plot_model输出</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 通过plot_model观察模型结构</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>plot_model<span class="token punctuation">(</span>test_model<span class="token punctuation">.</span>build_graph<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> to_file<span class="token operator">=</span><span class="token string">'./test_model.png'</span><span class="token punctuation">,</span> show_shapes<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/plot_model-output.4hufd4olsw40.webp" alt="plot_model-output"></p>]]></content>
    
    
    <categories>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>subclassing</tag>
      
      <tag>save model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>airflow自定义operator</title>
    <link href="/2022/04/24/airflow/airflow%E8%87%AA%E5%AE%9A%E4%B9%89operator/"/>
    <url>/2022/04/24/airflow/airflow%E8%87%AA%E5%AE%9A%E4%B9%89operator/</url>
    
    <content type="html"><![CDATA[<p>任意的自定义我们需要的operator是airlfow的一大优势，这极大的方便了我们在日常开发调度流程中的灵活性和可拓展性。</p><span id="more"></span><h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h1><p>自定义airflow-operator的时候需要继承<code>airflow.models.baseoperator.BaseOperator</code>.<br>同时，至少需要对基类里的两个方法进行重写：</p><ol><li>Constructor<ul><li>定义当前operator需要使用到的参数。</li></ul></li><li>Execute：<ul><li>当operator进行执行的时候需要执行的代码。</li></ul></li></ol><p><strong>一个基本的自定义Operator的例子</strong>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> airflow<span class="token punctuation">.</span>models<span class="token punctuation">.</span>baseoperator <span class="token keyword">import</span> BaseOperator<span class="token keyword">class</span> <span class="token class-name">HelloOperator</span><span class="token punctuation">(</span>BaseOperator<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>slef<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        <span class="token keyword">def</span> <span class="token function">execute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>        message <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"Hello </span><span class="token interpolation"><span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span>        <span class="token keyword">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>        <span class="token keyword">return</span> message<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>airflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>airflow</tag>
      
      <tag>调度器</tag>
      
      <tag>custom</tag>
      
      <tag>operator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行常用快捷键</title>
    <link href="/2022/04/24/linux/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2022/04/24/linux/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些常用的Linux命令行快捷键</p></blockquote><span id="more"></span><table><thead><tr><th>快捷键</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>Ctrl + l</td><td>清除当前屏幕</td><td></td></tr><tr><td>Ctrl + m</td><td>等效于回车</td><td></td></tr><tr><td>Ctrl + c</td><td>中断当前正在终端执行的进程</td><td></td></tr><tr><td>Ctrl + p</td><td>上一条命令</td><td>类似向上箭头</td></tr><tr><td>Ctrl + n</td><td>下一条命令</td><td>类似向下箭头</td></tr><tr><td>Ctrl + r</td><td>根据输入的字符串对历史命令进行检索</td><td></td></tr><tr><td>Ctrl + a</td><td>移动光标到行首</td><td></td></tr><tr><td>Ctrl + e</td><td>移动光标当行尾</td><td></td></tr><tr><td>Ctrl + b</td><td>光标后退</td><td></td></tr><tr><td>Ctrl + f</td><td>光标前进</td><td>会和oh-my-zsh的快捷键冲突</td></tr><tr><td>Ctrl + h</td><td>删除光标的前一个字符</td><td></td></tr><tr><td>Ctrl + d</td><td>删除光标所在的字符</td><td></td></tr><tr><td>Ctrl + k</td><td>删除光标之后的所有字符</td><td></td></tr><tr><td>Ctrl + u</td><td>清空当前输入的命令</td><td></td></tr><tr><td>Ctrl + w</td><td>删除光标前的单词</td><td>以空格分割的一部分</td></tr><tr><td>Ctrl + y</td><td>粘贴Ctrl + w或Ctrl + k删除的内容</td><td>Ctrl + h和Ctrl + d删除的内容不行</td></tr><tr><td>Ctrl + z</td><td>把当前的进程放到后台执行</td><td>可以通过’fg’使放到后台的进程回到前台</td></tr><tr><td>Ctrl + x &amp; Ctrl + e</td><td>使用系统自带的编辑器编辑当前输入的命令</td><td>适用于较长的命令需要编辑的时候</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快捷键</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>airflow状态说明</title>
    <link href="/2022/04/23/airflow/airflow%E7%8A%B6%E6%80%81%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/04/23/airflow/airflow%E7%8A%B6%E6%80%81%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>在airflow中，可以通过对pipeline中的不同task赋予不同的状态(state)说明当前任务的执行进度。通过airflow的状态机制，可以对当前的任务执行进度和状态进行很好的把控，及时了解指定任务的情况。</p><p>其中，airflow在更新到2.0版本后，相较于之前的1.9.0版本，airflow对任务状态进行了进一步的细化说明。本文主要是为了对airflow的基础状态信息进行一个简单的介绍和记录。</p><span id="more"></span><h1 id="1-airflow状态说明"><a href="#1-airflow状态说明" class="headerlink" title="1. airflow状态说明"></a>1. airflow状态说明</h1><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-all-state.2g0opkilfqck.webp" alt="airflow-all-state"></p><h2 id="1-1-通过颜色区分"><a href="#1-1-通过颜色区分" class="headerlink" title="1.1 通过颜色区分"></a>1.1 通过颜色区分</h2><p>airflow中的状态标识蕾丝红绿灯的状态区分，主要分成了红、黄、绿三种基础状态。在此基础上，针对三种不同的颜色范围，进行了进一步的细化标识来表明不同的细化状态。</p><h2 id="1-2-通过粒度区分"><a href="#1-2-通过粒度区分" class="headerlink" title="1.2 通过粒度区分"></a>1.2 通过粒度区分</h2><p>除此之外，airflow状态还会根据标明级别，分成了dag状态和task状态两大类，不同类别的状态主要有如下几个小类：</p><ol><li>Dagrun：SUCCESS, RUNNING, FAILED</li><li>Task：SUCCESS, RUNNING, FAILED, UPSTREAM_FAILED, SKIPPED, UP_FOR_RETRY, UP_FOR_RESCHEDULE, QUEUED, NONE, SCHEDULED</li></ol><p>其中，Task状态主要是针对Dagrun状态的细化说明，因为Dag中不同task因为执行时间、顺序和依赖的不同，会有不同的状态表现。</p><h2 id="1-3-通过状态范围区分"><a href="#1-3-通过状态范围区分" class="headerlink" title="1.3 通过状态范围区分"></a>1.3 通过状态范围区分</h2><p>同时，可以通过是否会继续进行状态变更，分成完成（finished）和未完成（unfinished）两大类。</p><ul><li>完成状态代表airflow scheduler不会对当前task&#x2F;dagrun进行监控。</li><li>未完成状态代表当前task&#x2F;dagrun的状态还会发生变更，最终会达到一个完成状态。</li></ul><h1 id="2-airflow状态的详细介绍"><a href="#2-airflow状态的详细介绍" class="headerlink" title="2. airflow状态的详细介绍"></a>2. airflow状态的详细介绍</h1><h3 id="2-1-SUCCESS（green｜dagrun｜task｜finished）"><a href="#2-1-SUCCESS（green｜dagrun｜task｜finished）" class="headerlink" title="2.1 SUCCESS（green｜dagrun｜task｜finished）"></a>2.1 SUCCESS（green｜dagrun｜task｜finished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-success-state.2n720i3oq4u0.webp" alt="airflow-success-state"></p><ul><li>success状态说明当前任务在执行过程中没有检测到错误信息，并正常完成。</li><li>airflow scheduler上报状态后，释放针对当前任务的监控。</li><li>excutor执行完成对应任务</li><li>颜色：墨绿色</li></ul><h3 id="2-2-RUNNING（green｜dagrun｜task｜unfinished）"><a href="#2-2-RUNNING（green｜dagrun｜task｜unfinished）" class="headerlink" title="2.2 RUNNING（green｜dagrun｜task｜unfinished）"></a>2.2 RUNNING（green｜dagrun｜task｜unfinished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-running-state.2hjc0rbgou60.webp" alt="airflow-running-state"></p><ul><li>running状态代表当前的任务执行执行中</li><li>airflow scheduler将该任务提交到了executor上，并对当前任务通过heartbeat进行监控</li><li>executor正在对对应的实际任务进行执行</li><li>颜色：浅绿色</li><li>后续状态：SUCCESS、RETRY、FAILED</li></ul><h3 id="2-3-FAILED（red｜dagrun｜task｜finished）"><a href="#2-3-FAILED（red｜dagrun｜task｜finished）" class="headerlink" title="2.3 FAILED（red｜dagrun｜task｜finished）"></a>2.3 FAILED（red｜dagrun｜task｜finished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-failed-state.6vbtjqjxw8g0.webp" alt="airflow-failed-state"></p><ul><li>failed状态说明当前任务执行失败，返回了错误状态码，airflow监控到了当前错误，表现在web上</li><li>airflow scheduler会上报当前任务failed壮体啊，和下游任务的UPSTREAM_FAILED状态</li><li>executor执行完成对应任务</li><li>颜色：红色</li></ul><h3 id="2-4-UPSTREAM-FAILED（red｜task｜finished）"><a href="#2-4-UPSTREAM-FAILED（red｜task｜finished）" class="headerlink" title="2.4 UPSTREAM_FAILED（red｜task｜finished）"></a>2.4 UPSTREAM_FAILED（red｜task｜finished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-upstream-failed-state.3m701qkvfc80.webp" alt="airflow-upstream_upfailed-state"></p><ul><li>upstream_failed状态说明当前任务的上游任务发生错误，上有task处于FAILED状态，当前任务并没有开始执行</li><li>airflow scheduler会直接上报当前任务状态，不会再将当前任务进行调度</li><li>executor没有执行对应的任务</li><li>颜色：棕黄色</li></ul><h3 id="2-5-SKIPPED（red｜task｜finished）"><a href="#2-5-SKIPPED（red｜task｜finished）" class="headerlink" title="2.5 SKIPPED（red｜task｜finished）"></a>2.5 SKIPPED（red｜task｜finished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-skipped-state.2oekru2jpa60.webp" alt="airflow-skipped-state"></p><ul><li>skipped状态代表当前任务被跳过，没有进行执行，经常发生在branchOperator未触发的分支上</li><li>airflow scheduler绕过了当前任务，并没有调度</li><li>executor没有执行对应的任务</li><li>颜色：浅红色</li></ul><h3 id="2-6-UP-FOR-RETRY（yellow｜task｜unfinished）"><a href="#2-6-UP-FOR-RETRY（yellow｜task｜unfinished）" class="headerlink" title="2.6 UP_FOR_RETRY（yellow｜task｜unfinished）"></a>2.6 UP_FOR_RETRY（yellow｜task｜unfinished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-up-for-retry-state.h2tpvfwe4lc.webp" alt="airflow-up_for_retry-state"></p><ul><li>up_for_retry代表当前任务执行失败并在等待重试中</li><li>airflow scheduler会在retry interval之后，下一次heartbeat到达时重新调度该任务</li><li>executor上次执行对应任务失败，上次执行过程已经结束，当前没有执行对应任务</li><li>颜色：黄色</li></ul><h3 id="2-7-UP-FOR-RESCHEDULE（green｜task｜unfinished）"><a href="#2-7-UP-FOR-RESCHEDULE（green｜task｜unfinished）" class="headerlink" title="2.7 UP_FOR_RESCHEDULE（green｜task｜unfinished）"></a>2.7 UP_FOR_RESCHEDULE（green｜task｜unfinished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-up_for_reschedule-state.1bo58g36z6qo.webp" alt="airflow-up_for_reschedule-state"></p><ul><li>up_for_reschedule是在airflow1.10.2中引入的心状态，常用在Sensor中，可以防止过度消耗slots</li><li>airflow scheduler会对当前的任务进行定时尝试，防止因为长时间处在调度过程中而占据worker slots，从而导致worker锁死，无法执行其他任务</li><li>executor定时执行对应任务</li><li>颜色：浅绿色</li></ul><h3 id="2-8-QUEUED（grey｜task｜unfinished）"><a href="#2-8-QUEUED（grey｜task｜unfinished）" class="headerlink" title="2.8 QUEUED（grey｜task｜unfinished）"></a>2.8 QUEUED（grey｜task｜unfinished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-queued-state.13weqa9jfna8.webp" alt="airflow-queued-state"></p><ul><li>queued状态代表当前任务已经被调度，但是正在等待一个可用的executor slots</li><li>airflow scheduler已经将该任务调度，正在排队中，当前的pool中没用slots为0</li><li>executor没有空闲的slots执行该任务，或者提交到指定的executor的concurrency已经最大，无法在接受新任务</li><li>颜色：灰色</li></ul><h3 id="2-9-NO-STATUS（no｜task｜unfinished）"><a href="#2-9-NO-STATUS（no｜task｜unfinished）" class="headerlink" title="2.9 NO_STATUS（no｜task｜unfinished）"></a>2.9 NO_STATUS（no｜task｜unfinished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-no_status-state.3b4t9j1ta8k0.webp" alt="airflow-no_status-state"></p><ul><li>no_status代表当前任务还没有被调度到，前面任务正在执行</li><li>颜色：无颜色</li></ul><h3 id="2-10-SCHEDULED（yellow｜task｜unfinished）"><a href="#2-10-SCHEDULED（yellow｜task｜unfinished）" class="headerlink" title="2.10 SCHEDULED（yellow｜task｜unfinished）"></a>2.10 SCHEDULED（yellow｜task｜unfinished）</h3><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-scheduled-state.7io0ibe2l5s0.webp" alt="airflow-scheduled-state"></p><ul><li>scheduled状态代表该任务已经被触发</li><li>airflow scheduler调度该任务，但是并没有open slots（&#x3D;all_slots - running_slots - queued_slots），正在轮询状态中</li><li>excutor没有空闲的slots执行该任务</li><li>颜色：棕色</li></ul>]]></content>
    
    
    <categories>
      
      <category>airflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>airflow</tag>
      
      <tag>调度器</tag>
      
      <tag>状态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>airflow简单部署</title>
    <link href="/2022/04/22/airflow/airflow%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/22/airflow/airflow%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>airflow是airbnb开源的一套可以灵活管理工作流的自动化和调度系统</p></blockquote><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/airflow-show.59g4ioncbzs0.webp" alt="airflow-show"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>airflow是一个apache孵化的开源的基于有向无环图调度和监控平台。具有以下的优点</p><ol><li>灵活易用。工作流定义通过python编写，容易定制化，而且代码可读性较高</li><li>支持任务丰富。通过Operator支持常见的任务类型，类似shell，python，ssh···</li><li>方便拓展。支持热式扩展执行节点。通过Celery可以部署多个worker，几乎可以做到无限扩展。<ol><li>分布式部署worker的时候运行工作流上的每个task在不同的worker上执行</li></ol></li><li>task粒度的操作：<ol><li>工作流上的每个task都是可以独立重试的。一个工作流的某个task失败不需要从头开始</li></ol></li></ol><h4 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h4><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/struct-airflow.6fhpplr7k640.webp" alt="airflow-struct"></p><ol><li>界面展示和监控（webserver）<ol><li>进行web段的dag&#x2F;task，log等信息的展示</li></ol></li><li>执行器（worker）<ol><li>执行具体的任务（task）</li><li>主要分成SequentiaExecutor, LocalExecutor, CeleryExecutor三种</li></ol></li><li>调度器（scheduler）<ol><li>任务调度器，根据dags生成要执行的任务，并控制任务队列（类似crontab）</li><li>使用CeleryExecutor的时候也负责提交消息到中间件队列（redis或rabbitMq）</li></ol></li><li>数据库（database）<ol><li>存储任务、dags、变量、连接等信息</li></ol></li><li>celery<ol><li>分布式队列控制器</li><li>主要由Broker（代理）和Result Backend（结果后端）构成<ol><li>Broker 负责存储执行的命令</li><li>Result Backend存储完成执行命令的状态信息</li></ol></li></ol></li></ol><h4 id="各组件之间的通信逻辑"><a href="#各组件之间的通信逻辑" class="headerlink" title="各组件之间的通信逻辑"></a>各组件之间的通信逻辑</h4><ul><li>数字和上图一一对应</li></ul><table><thead><tr><th>服务</th><th>链接服务</th><th>说明</th></tr></thead><tbody><tr><td>Web server</td><td>Workers</td><td>获取任务执行的日志信息</td></tr><tr><td>Webserver</td><td>DAG file</td><td>从dags文件夹的dag配置文件中读取dag结构并展示</td></tr><tr><td>Webserver</td><td>Database</td><td>获取任务状态信息</td></tr><tr><td>Workers</td><td>DAG files</td><td>执行任务</td></tr><tr><td>Workers</td><td>Database</td><td>读取和写入connections、Xcoms等信息</td></tr><tr><td>Workers</td><td>Celery’s Result backend</td><td>存储任务执行信息，任务状态等</td></tr><tr><td>Workers</td><td>Celery’s Queue broker</td><td>存储执行的命令</td></tr><tr><td>Scheduler</td><td>DAG files</td><td>存储DAG的结构和任务调度时间等，并控制任务执行</td></tr><tr><td>Scheduler</td><td>Database</td><td>存储DAG运行的信息和相关任务</td></tr><tr><td>Scheduler</td><td>Celery’s Result backend</td><td>获取已经执行的的任务信息，状态</td></tr><tr><td>Scheduler</td><td>Celery’s Queue broker</td><td>发送任务执行命令到Celery’s broker</td></tr></tbody></table><h2 id="本地docker部署"><a href="#本地docker部署" class="headerlink" title="本地docker部署"></a>本地docker部署</h2><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:latest  # 拉取基础镜像</span><span class="token instruction"><span class="token keyword">MAINTAINER</span> *** <span class="token string">"***@foxmail.com"</span></span><span class="token instruction"><span class="token keyword">RUN</span> apt-get update  # 更新软件源</span><span class="token instruction"><span class="token keyword">RUN</span> apt-get -y install python   # 安装python</span><span class="token instruction"><span class="token keyword">RUN</span> ln -fs /usr/bin/python3 /usr/bin/python   # 更新python对应的软连接到python3</span><span class="token instruction"><span class="token keyword">RUN</span> apt-get -y install python3-pip    # 安装pip</span><span class="token instruction"><span class="token keyword">RUN</span> /usr/bin/pip3 install --upgrade pip   # 更行pip到最新版本，防止后续安装过程中出现问题</span><span class="token instruction"><span class="token keyword">RUN</span> export AIRFLOW_HOME=/home/darren/airflow</span><span class="token instruction"><span class="token keyword">RUN</span> export SLUGIFY_USES_TEXT_UNIDECODE=yes</span><span class="token instruction"><span class="token keyword">RUN</span> /usr/local/bin/pip3 install apache-airflow  # 安装airflow</span><span class="token instruction"><span class="token keyword">EXPOSE</span> 8080   # 暴漏指定端口</span><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">'airflow db init'</span>]</span><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">'airflow users create --username admin --password admin --firstname ** --lastname ** --role Admin --email ****@foxmail.com'</span>]</span><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">'airflow webserver -D -p 8080'</span>]</span><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">'airflow scheduler -D'</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="airflow的dag例子"><a href="#airflow的dag例子" class="headerlink" title="airflow的dag例子"></a>airflow的dag例子</h2><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">from</span> airflow <span class="token keyword">import</span> DAG<span class="token keyword">from</span> airflow<span class="token punctuation">.</span>operators<span class="token punctuation">.</span>dummy <span class="token keyword">import</span> DummyOperator<span class="token keyword">from</span> airflow<span class="token punctuation">.</span>operators<span class="token punctuation">.</span>python <span class="token keyword">import</span> BranchPythonOperator<span class="token keyword">from</span> airflow<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>dates <span class="token keyword">import</span> days_agoargs <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'owner'</span><span class="token punctuation">:</span> <span class="token string">'airflow'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>dag <span class="token operator">=</span> DAG<span class="token punctuation">(</span>    dag_id<span class="token operator">=</span><span class="token string">'example_branch_operator'</span><span class="token punctuation">,</span><span class="token comment"># dag名字，即显示在airflow上的名字</span>    default_args<span class="token operator">=</span>args<span class="token punctuation">,</span><span class="token comment"># 默认参数</span>    start_date<span class="token operator">=</span>days_ago<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    schedule_interval<span class="token operator">=</span><span class="token string">"@daily"</span><span class="token punctuation">,</span><span class="token comment"># 调度循环时间</span>    tags<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'example'</span><span class="token punctuation">,</span> <span class="token string">'example2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment"># 当前dag的tag，方便查询标注</span><span class="token punctuation">)</span><span class="token comment"># 初始化的operator, dag的开头</span>run_this_first <span class="token operator">=</span> DummyOperator<span class="token punctuation">(</span>    task_id<span class="token operator">=</span><span class="token string">'run_this_first'</span><span class="token punctuation">,</span>    dag<span class="token operator">=</span>dag<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment"># 候选的分支大operator的task_id</span>options <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'branch_a'</span><span class="token punctuation">,</span> <span class="token string">'branch_b'</span><span class="token punctuation">,</span> <span class="token string">'branch_c'</span><span class="token punctuation">,</span> <span class="token string">'branch_d'</span><span class="token punctuation">]</span><span class="token comment"># 创建分支operator, python callable的结果返回要执行的task_id，可以是自定义函数</span>branching <span class="token operator">=</span> BranchPythonOperator<span class="token punctuation">(</span>    task_id<span class="token operator">=</span><span class="token string">'branching'</span><span class="token punctuation">,</span>    python_callable<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">,</span>    dag<span class="token operator">=</span>dag<span class="token punctuation">,</span><span class="token punctuation">)</span>run_this_first <span class="token operator">>></span> branchingjoin <span class="token operator">=</span> DummyOperator<span class="token punctuation">(</span>    task_id<span class="token operator">=</span><span class="token string">'join'</span><span class="token punctuation">,</span>    trigger_rule<span class="token operator">=</span><span class="token string">'none_failed_or_skipped'</span><span class="token punctuation">,</span>    dag<span class="token operator">=</span>dag<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment"># 针对不同的分支情况创建不同的任务</span><span class="token keyword">for</span> option <span class="token keyword">in</span> options<span class="token punctuation">:</span>    t <span class="token operator">=</span> DummyOperator<span class="token punctuation">(</span>        task_id<span class="token operator">=</span>option<span class="token punctuation">,</span>        dag<span class="token operator">=</span>dag<span class="token punctuation">,</span>    <span class="token punctuation">)</span>    dummy_follow <span class="token operator">=</span> DummyOperator<span class="token punctuation">(</span>        task_id<span class="token operator">=</span><span class="token string">'follow_'</span> <span class="token operator">+</span> option<span class="token punctuation">,</span>        dag<span class="token operator">=</span>dag<span class="token punctuation">,</span>    <span class="token punctuation">)</span>    branching <span class="token operator">>></span> t <span class="token operator">>></span> dummy_follow <span class="token operator">>></span> join<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="airflow使用过程的注意事项"><a href="#airflow使用过程的注意事项" class="headerlink" title="airflow使用过程的注意事项"></a>airflow使用过程的注意事项</h2><h4 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h4><ul><li>为了防止不同集群内部时区的差异，airflow全局统一使用UTC时间。</li><li>2.0中可以通过配置实现指定时区</li></ul><h4 id="execute-date"><a href="#execute-date" class="headerlink" title="execute date"></a>execute date</h4><ul><li>execute date 并不是当前任务的执行时间，而是airflow前一个运行周期的运行时间</li><li>例如：dag1每天11:00开始运行，那么在 ​2021-04-01 11:00​ 启动的任务对应的execute_date应该是 ​2021-03-31 11:00​</li></ul>]]></content>
    
    
    <categories>
      
      <category>airflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>airflow</tag>
      
      <tag>调度器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oh-my-zsh安装和使用</title>
    <link href="/2022/04/21/linux/oh-my-zsh%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/21/linux/oh-my-zsh%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="oh-my-zsh安装"><a href="#oh-my-zsh安装" class="headerlink" title="oh-my-zsh安装"></a>oh-my-zsh安装</h2><p>oh-my-zsh是是针对zsh命令行环境的配置包装框架，通过它，我们可以省去针对zsh繁琐的配置过程，几乎达到开箱即用的地步。</p><span id="more"></span><p>oh-my-zsh可以通过脚本进行安装：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>安装之后，是zsh的默认界面，相对比较简陋，看起来和bash并没有什么区别，但是我们可以通过丰富的插件配置完成zsh的一个蜕变。下面介绍两款常用的oh-my-zsh配置。</p><h2 id="插件、主题选择和配置"><a href="#插件、主题选择和配置" class="headerlink" title="插件、主题选择和配置"></a>插件、主题选择和配置</h2><p>oh-my-zsh的插件安装方式非常简单，只需要将对应插件的工程clone到oh-my-zsh的plugins文件夹下，并通过配置文件进行简单配置即可使用。</p><h4 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token punctuation">\</span>    https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="token punctuation">\</span>    <span class="token variable">$&#123;ZSH_CUSTOM<span class="token operator">:-</span>~<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom&#125;</span>/plugins/zsh-syntax-highlighting<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h4><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token punctuation">\</span>    git://github.com/zsh-users/zsh-autosuggestions.git <span class="token punctuation">\</span>    <span class="token variable">$&#123;ZSH_CUSTOM<span class="token operator">:-</span>~<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom&#125;</span>/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>插件clone完成后，重启zsh或者<code>source ~/.zshrc</code>即可。</p><h2 id="oh-my-zsh的更新"><a href="#oh-my-zsh的更新" class="headerlink" title="oh-my-zsh的更新"></a>oh-my-zsh的更新</h2><p>oh-my-zsh更新检测命令<code>omz update</code></p><h2 id="常见的alias命令"><a href="#常见的alias命令" class="headerlink" title="常见的alias命令"></a>常见的alias命令</h2><p>alias极大的简化了对日常常用命令的使用，可以将自己常用的命令通过alias进行简化使用。<br>同时oh-my-zsh中内置了大量的alias方便使用，可以通过<code>alias</code>命令显示oh-my-zsh里内置的命令。<br>常见的命令如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">g</span><span class="token operator">=</span>git<span class="token assign-left variable">ga</span><span class="token operator">=</span><span class="token string">'git add'</span><span class="token assign-left variable">gb</span><span class="token operator">=</span><span class="token string">'git branch'</span><span class="token assign-left variable">gc</span><span class="token operator">=</span><span class="token string">'git commit'</span><span class="token assign-left variable">gco</span><span class="token operator">=</span><span class="token string">'git checkout'</span><span class="token assign-left variable">gst</span><span class="token operator">=</span><span class="token string">'git status'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>livy的部署和使用</title>
    <link href="/2022/04/20/linux/livy%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/20/linux/livy%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Livy概述"><a href="#Livy概述" class="headerlink" title="Livy概述"></a>Livy概述</h2><p>Livy是Apache Spark的一个REST服务，通过Livy，可以实现在任意的平台上通过Http请求提交Spark任务。</p><ul><li>通过livy提交的spark任务，对原始的spark脚本没有任何入侵</li><li>livy支持多用户、多任务并行的和spark集群进行交互</li><li>可以在python、scala、java中通过livy进行spark批任务的处理<span id="more"></span></li></ul><h2 id="Livy部署"><a href="#Livy部署" class="headerlink" title="Livy部署"></a>Livy部署</h2><p>Livy的部署只需要在spark集群的master节点上进行部署即可。<br>这里默认依赖的spark和hadoop都已经就位，并不需要从头安装。</p><h3 id="下载livy"><a href="#下载livy" class="headerlink" title="下载livy"></a>下载livy</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载地址：http://livy.incubator.apache.org/download/</span><span class="token function">wget</span> https://www.apache.org/dyn/closer.lua/incubator/livy/0.7.1-incubating/apache-livy-0.7.1-incubating-bin.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ol><li><p>修改livy.conf</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> livy.conf.template livy.conf <span class="token operator">&amp;</span> <span class="token function">vim</span> livy.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>需要调整的基础信息如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#Livy会话所使用的Spark集群运行模式</span>livy.spark.master = yarn<span class="token comment">#######其他可以根据自身项目需求进行设置，不想修改默认就好########</span><span class="token comment">#Livy会话所使用的Spark集群部署模式</span>livy.spark.deploy<span class="token punctuation">-</span>mode=cluster<span class="token comment">#默认使用hiveContext</span>livy.repl.enable<span class="token punctuation">-</span>hive<span class="token punctuation">-</span>context = true<span class="token comment">#开启用户代理</span>livy.impersonation.enabled = true<span class="token comment">#设置session空闲过期时间</span>livy.server.session.timeout = 1h<span class="token comment">#yarn/local本地模式或者yarn模式</span>livy.server.session.factory = yarn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li><li><p>修改livy-env.sh</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> livy-env.sh.template livy-env.sh <span class="token operator">&amp;</span> <span class="token function">vim</span> livy-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>需要调整的基础信息如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#Spark安装目录</span>HADOOP_CONF_DIR=/opt/software/hadoop<span class="token punctuation">-</span>3.0.0/etc/hadoop<span class="token comment">#Hadoo配置目录</span>SPARK_HOME=/opt/software/spark<span class="token punctuation">-</span>2.5.2<span class="token punctuation">-</span>bin<span class="token punctuation">-</span>without<span class="token punctuation">-</span>hadoop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ol><h3 id="启动Livy"><a href="#启动Livy" class="headerlink" title="启动Livy"></a>启动Livy</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动livy</span>./apache-livy-0.7.1-incubating-bin/bin/livy-server start<span class="token comment"># 关闭livy</span>./apache-livy-0.7.1-incubating-bin/bin/livy-server stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="Livy使用"><a href="#Livy使用" class="headerlink" title="Livy使用"></a>Livy使用</h2><p>livy默认的接口为8998, 在配置文件没有显式的声明其他端口的时候，可以直接向当前的端口提交任务。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 提交任务</span><span class="token function">curl</span> <span class="token parameter variable">-H</span> <span class="token string">"Content-Type: application/json"</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">'&#123;"driverMemory": "20G","numExecutors": 60,"executorCores": 4,"executorMemory": "25G","conf": &#123;"spark.dynamicAllocation.enabled": "False","spark.default.arallelism": "2000","spark.sql.shuffle.partitions": "200","spark.memory.fraction": "0.8","spark.port.maxRetries": "256"&#125;,"file": "$&#123;file_path_on_hdfs&#125;","args": ["--date=20220420"]&#125;'</span> http://<span class="token variable">$&#123;spark-master-url&#125;</span>:8998/batches/ <span class="token operator">|</span> python <span class="token parameter variable">-m</span> json.tool<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>通过上述命令提交后，返回如下，会包含生成的livy-session的id。<br><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/livy-submit-return.4gg7kd0zu8w0.webp" alt="livy-submit-return"></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 获取指定batch_id的session状态</span><span class="token function">curl</span> <span class="token parameter variable">-X</span> GET http://<span class="token variable">$&#123;spark-master-url&#125;</span>:8998/batches/<span class="token variable">$&#123;batch_id&#125;</span>/state <span class="token operator">|</span> python <span class="token parameter variable">-m</span> json.tool<span class="token comment"># 获取指定batch_id的session-log</span><span class="token function">curl</span> <span class="token parameter variable">-X</span> GET http://<span class="token variable">$&#123;spark-master-url&#125;</span>:8998/batches/<span class="token variable">$&#123;batch_id&#125;</span>/log <span class="token operator">|</span> python <span class="token parameter variable">-m</span> json.tool<span class="token comment"># 中断指定batch_id的session，同时会中断application</span><span class="token function">curl</span> <span class="token parameter variable">-X</span> DELETE http://<span class="token variable">$&#123;spark-master-url&#125;</span>:8998/batches/<span class="token variable">$&#123;batch_id&#125;</span> <span class="token operator">|</span> python <span class="token parameter variable">-m</span> json.tool<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>livy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>livy</tag>
      
      <tag>spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo自动化部署</title>
    <link href="/2022/04/19/blog/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/19/blog/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h2><blockquote><p>github action 是一个持续集成（Continuous intergration）和持续交付（Continuous deluvery）的平台，他可以做到自动化构建、测试、部署。</p></blockquote><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/github-actions.67mq8c0v6xk0.webp" alt="github action官方仓库"></p><p>我们可以通过github action的逻辑自动化部署位于git-pages上的个人博客，省去频繁的个人同步的操作。<br>而且针对其他难以在个人电脑上进行编译的庞大宫成，也可以历史github action提供的runner进行编译。<br>接下来的内容是我通过github action进行自动化部署hexo个人blog的经验。</p><h2 id="依赖准备"><a href="#依赖准备" class="headerlink" title="依赖准备"></a>依赖准备</h2><p>针对hexo，我们需要提供必要的md文件，剩余的内容可以通过hexo进行自动生成和部署，具体需要部署的内容是经过了<code>hexo generate</code>之后生成<code>public</code>文件夹。<br>将生成完成的<code>public</code>文件夹同步到名为<code>$&#123;user-name&#125;.github.io</code>github工程的master分支后，github会自动将该内容发布到<code>http://$&#123;user-name&#125;.github.io</code>的网页上，方便进行查看。<br><img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/github.3xvjh9pmt1w0.webp" alt="github.io"></p><h3 id="仓库准备"><a href="#仓库准备" class="headerlink" title="仓库准备"></a>仓库准备</h3><p>因此，我们至少需要准备两个仓库（或者分支）。</p><ol><li>存储<code>public</code>文件夹<ol><li>使用<code>$&#123;user-name&#125;.github.io</code>仓库的<code>master</code>分支</li></ol></li><li>存储md文件源代码和相关配置文件<ol><li>可以使用任务仓库的任意分支</li><li>我这里使用的是<code>$&#123;user-name&#125;.github.io</code>的<code>source-files</code>分支</li></ol></li></ol><h3 id="配置文件准备"><a href="#配置文件准备" class="headerlink" title="配置文件准备"></a>配置文件准备</h3><p>配置文件主要分成网站配置文件和主题配置文件两部分。</p><ol><li>网站配置文件<ol><li>控制网站基本信息</li></ol></li><li>主题配置文件<ol><li>如果你安装了自己的主题的话，会处于<code>./themes/$&#123;theme-name&#125;/</code>下，用来控制主题的相关配置</li></ol></li></ol><h3 id="本地文件准备和同步"><a href="#本地文件准备和同步" class="headerlink" title="本地文件准备和同步"></a>本地文件准备和同步</h3><ol><li>准备好本地文件。<br> 具体的文件夹结构可以参考下图:<br> <img src="https://cdn.jsdelivr.net/gh/ZermZhang/pictures@main/PicX/source-files-struct.4axb9h4v4bw0.webp" alt="source-files-struct"></li><li>将准备好的文件同步到线上指定的仓库或分支里。</li></ol><h2 id="线上github-action的workflow编写"><a href="#线上github-action的workflow编写" class="headerlink" title="线上github-action的workflow编写"></a>线上github-action的workflow编写</h2><p>这里是整个部署过程的核心部分，在github-action的运行过程中，我们会集成和Hexo相关的操作，包括<code>hexo clean</code>和<code>hexo generate</code>和主题安装的过程。<br>目的就是为了将过去我们需要手动处理的流程，全部通过github-action进行自动化处理。</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Hexo Deploy<span class="token key atrule">on</span><span class="token punctuation">:</span>   <span class="token comment"># 指定在什么条件下执行当前workflow</span>  <span class="token key atrule">push</span><span class="token punctuation">:</span>   <span class="token comment"># 在push的时候触发workflow，可选值也包括pull_request</span>    <span class="token key atrule">branches</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> source<span class="token punctuation">-</span>files  <span class="token comment"># 推送到分支source-files的时候执行当前worklflow</span><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">build</span><span class="token punctuation">:</span>    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span><span class="token number">18.04</span>   <span class="token comment"># 基于ubuntu-18.04执行下述任务</span>    <span class="token key atrule">if</span><span class="token punctuation">:</span> github.event.repository.owner.id == github.event.sender.id  <span class="token comment"># 只有当推送owner和当前仓库owner一致是运行</span>    <span class="token key atrule">steps</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout source   <span class="token comment"># check到source-files分支</span>        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v2        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">ref</span><span class="token punctuation">:</span> source<span class="token punctuation">-</span>files      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Configration hexo repo    <span class="token comment"># 配置github密钥</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>          <span class="token key atrule">ACTION_DEPLOY_KEY</span><span class="token punctuation">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> secrets.MY_SECRET <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">          mkdir -p ~/.ssh/          echo "$ACTION_DEPLOY_KEY" > ~/.ssh/id_rsa          chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com >> ~/.ssh/known_hosts          git config --global user.email "zhang371312@126.com"          git config --global user.name "ZermZhang"</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout submodules        <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">          git submodule init          git submodule update</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Node.js     <span class="token comment"># 安装node.js</span>        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>node@v1        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">node-version</span><span class="token punctuation">:</span> <span class="token string">'12'</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Hexo    <span class="token comment"># 安装hexo</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">          npm install -g hexo-cli</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Generate files    <span class="token comment"># 构建hexo博客工程</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">          hexo init myblog          cd myblog          npm install          git clone https://github.com/theme-next/hexo-theme-next themes/next</span>          cp <span class="token punctuation">-</span>r ../sites/* ./          hexo clean          hexo generate      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Deploy hexo blog    <span class="token comment"># 将生成的工程文件上传到master分支</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>          <span class="token comment"># Github 仓库</span>          <span class="token key atrule">GITHUB_REPO</span><span class="token punctuation">:</span> github.com/$<span class="token punctuation">&#123;</span>user<span class="token punctuation">-</span>name<span class="token punctuation">&#125;</span>/$<span class="token punctuation">&#123;</span>user<span class="token punctuation">-</span>name<span class="token punctuation">&#125;</span>.github.io        <span class="token comment"># 将编译后的博客文件推送到指定仓库</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">          ls          cd ./myblog/public &amp;&amp; git init &amp;&amp; git add .          git config user.name "$&#123;user-name&#125;"          git config user.email "$&#123;user-mail&#125;"          git add .          git commit -m "GitHub Actions Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')"          git push --force --quiet "https://$&#123;&#123; secrets.MY_SECRET &#125;&#125;@$GITHUB_REPO" master:master</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>blog</tag>
      
      <tag>github</tag>
      
      <tag>自动化</tag>
      
      <tag>CICD</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
