---
title: 常见optimizers梳理
tags: ['machine-learning','optimizer']
date: 2022-07-29
categories: ['machine-learning']
math: true
---

> optimzer是在机器学习算法中的核心部分，针对常见的optimizer的具体实现原理和公式进行深入了解后，可以对使用模型训练过程中的问题分析有明显的帮助。

# 1. 优化器基本思路
常见的优化器基本都是通过梯度下降（Gradient Descent）的方法对模型的参数进行更新，使根据损失函数在测试集合上的损失值逐步降低，从而达到优化模型的目的。
这里按照常见优化器的更新和提出过程对他们的基本原理和更新公式进行一个梳理和备份。
在本文中可能会用的标记：
$$
\begin{align}
& \theta_{t}: 在时刻t的模型参数   \\\\
& \alpha: optimizer更新过程中的学习率   \\\\
& J: 损失函数 \\\\
& g_{t} = \frac{\partial J(\theta_{t})}{\partial \theta_{t}} = \nabla_{\theta}J(\theta): 在时刻t，损失函数相对\theta_{t}的导数 \\\\
& \beta: 加权平均的权重
\end{align}
$$

# 2. 常见优化器
## 2.1 随机梯度下降（SGD）
SGD是最传统、最基础的模型优化方法。
### 主要思路
* 在小批量的数据集上计算损失函数的梯度从而对模型的权重进行迭代更新。

### 更新公式
$$
\theta_{t} = \theta_{t-1} - \alpha * g(\theta_{t-1})
$$

### 优缺点
1. 过程简单，但是相对而言收敛速度可能比较慢
2. 每次更新时产生的梯度方向可能会产生较大的变化，从而导致更新方向的震荡，而陷入到局部最优点中。
    1. 更新过程中，batch的大小会影响到本次梯度的稳定性

## 2.2 动量优化方法（Momentum）
为了优化传统的SGD可能存在的更新方向震荡的问题，该方法在权重更新的过程中增加了针对梯度的累计动量的概念。
针对梯度的累积方法，这里采用了指数加权平均的逻辑，主要是为了对时间序列上的梯度赋予不同的权重，如下公式：
$$
\begin{align}
v_t = & \beta v_{t-1} + (1 - \beta)g_t \\\\
    = & \beta(\beta v_{t-2} + (1-\beta)g_{t-1}) + (1-\beta)g_{t} \\\\
    & \dots \\\\
    = & (1-\beta)(\beta^t g_0 + \beta^{t-1}g_1 + \dots + \beta g_{t-1} + g_t)
\end{align}
$$
通过如上公式处理，越靠近当前时间的梯度，它的权重越接近1，越远离当前时间的梯度，它的权重越接近0，这样既保证了能够累积过去时间的梯度情况，又能一定程度上保证靠近当前时间的梯度带来的影响。
最积累了足够优化步数的梯度之后，如果本次使用的梯度优化方向出现了较大的震荡，那么在梯度的累积值的影响下，会对本次优化方向进行较为明显的矫正，以消除抖动。

### 更新公式
$$
\begin{align}
v_t = & \beta v_{t-1} + (1-\beta) * g(\theta_{t-1}) \\\\
\theta_t = & \theta_{t - 1} - \alpha * v_t
\end{align}
$$

### 优缺点
1. 对更新过程的梯度进行了动量累积处理，对于和整体梯度方向一致的参数可以加速学习，对于和整体的梯度方向相反的参数可以降低更新次数。因此，该方法可在相关性更高的方向上进行加速学习，从而减少震荡、加速收敛过程
2. 同样是因为对梯度进行了累积，所以在后面的更新过程中，$v_t$会逐渐变大，如果学习率$\alpha$设置不好的话，会导致后期更新过程不容易完全熟练到最优点的情况。

## 2.3 自适应梯度下降（Adgrad）
Adgrad算法解决了因为梯度不断积累导致学习率不能很好的适应参数更新过程的问题。
在更新过程中，先将$g_t^2$全部记录下来，用来对当前次获取到的梯度更新方向的震荡进行矫正；然后，通过将累积下来的梯度平方作为分母对学习率进行调整。
在更新前期，梯度累积量较小，平滑之后的学习率依旧比较大，可以在一定程度上放大梯度，加速更新。
在更新后期，梯度累积量变大，平滑之后的学习率较小，可以在一定程度上缩小梯度，防止更新过程出现最优点附近的震荡。

### 更新公式
$$
\begin{align}
v_t = v_{t-1} + g_t^2 \\\\
h_t = \frac{\alpha}{v_t + \epsilon}g_t \\\\
\theta_t = \theta_{t-1} - h_t
\end{align}
$$

## 优缺点
1. 增加了学习率的自适应调整逻辑，可以根据更新过程自动调整学习率大小，根据情况获取不同的参数更新状态。
2. 因为梯度平方的累积一直在进行当中，后期可能会导致学习率被平滑到极小，导致收敛过程缓慢。

## 2.4 RMSprop
RMSprop算法结合了Adagrad和Momentum的优点，同时拥有了学习率自适应调整和梯度累积量根据时间序列调整的优点。
从下文的更新公式中可以看出，RMSprop的更新过程和Adagrad不同的地方在于对$g_t^2$进行累计的时候，没有使用简单直接的求和逻辑，而是使用了指数加权平均的逻辑。
这样，既保证了可以记录过去时间点上的$g_t$信息，也能保证累积下来的$v_t$不会出现无限增长的问题。

### 更新公式
$$
\begin{align}
v_t &= \beta v_{t-1} + (1 - \beta) g_t^2 \\\\
h_t &= \frac{\alpha}{v_t + \epsilon}g_t \\\\
\theta_t &= \theta_{t-1} - h_t
\end{align}
$$

### 优缺点
1. 使用指数加权平均对梯度累积过程进行了优化，防止在迭代后期对学习率$\alpha$进行过度的衰减，导致收敛过程缓慢。

## 2.5 Adam
Adam优化器结合了Adagrad和RMSprop两种优化器的优点，在对学习率更新的过程中考虑了梯度的一阶预估和二阶预估。
### 更新公式
$$
\begin{align}
m_t &= \beta_1\cdot m_{t-1} + (1-\beta_1)\cdot  g_t \\\\
v_t &= \beta_2\cdot v_{t-1} + (1-\beta_2)\cdot g_t^2 \\\\
\hat{m_t} &= \frac{m_t}{1-\beta_1^t} \\\\
\hat{v_t} &= \frac{v_t}{1-\beta_2^t} \\\\
\theta_t &= \theta_{t-1} - \alpha\cdot\frac{\hat{m_t}}{\sqrt{\hat{v_t}}+\epsilon}
\end{align}
$$

## 2.6 FTRL
### 更新公式
$$
\begin{align}
\end{align}
$$

## 2.7 FTML
### 更新公式
$$
\begin{align}
\end{align}
$$
